<!DOCTYPE html>
<html>
<head>
<base href="https://imperfiktillusion.github.io/weedtree/">
<title>WeedTree.fyi Strain Lineage Chart</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v6.min.js"></script>
<style>
/* unchanged styles â€“ omitted for brevity */
</style>
</head>
<body>

<!-- UI markup unchanged â€“ omitted for brevity -->

<script>
let strainData = [], nodes = [], svg, g, zoom, focusedNode = null, lineWidth = 2;

/* ===============================
   ðŸ”½ NEW: parent centroid helper
   =============================== */
function getParentCentroidY(node) {
    const parentYs = [];

    if (node.variant) {
        const parent = nodes.find(n => n.name === node.variant);
        if (parent && parent.y !== undefined) parentYs.push(parent.y);
    } else {
        node.parents.forEach(pid => {
            const parent = nodes.find(n => n.id === pid);
            if (parent && parent.y !== undefined) parentYs.push(parent.y);
        });
    }

    return parentYs.length ? d3.mean(parentYs) : null;
}

/* ==========================================
   ðŸ”½ NEW: dominance + parent-position sorting
   ========================================== */
function customSortColumnByParents(a, b) {
    const dominanceOrder = {
        'indica dominant': 0,
        'balanced hybrid': 1,
        'unknown': 2,
        'sativa dominant': 3,
        'ruderalis dominant': 4
    };

    const da = dominanceOrder[a.dominance?.toLowerCase()] ?? 99;
    const db = dominanceOrder[b.dominance?.toLowerCase()] ?? 99;
    if (da !== db) return da - db;

    const ay = getParentCentroidY(a);
    const by = getParentCentroidY(b);

    if (ay !== null && by !== null) return ay - by;
    if (ay !== null) return -1;
    if (by !== null) return 1;

    return a.name.localeCompare(b.name);
}

/* ===============================
   chart creation
   =============================== */
const createLineageChart = () => {
    const container = document.querySelector('.chart-container');
    const width = container.clientWidth;
    const height = container.clientHeight;

    d3.select("#lineageChart").selectAll("*").remove();
    svg = d3.select("#lineageChart").append("svg")
        .attr("width", width)
        .attr("height", height);

    g = svg.append("g");
    zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", e => g.attr("transform", e.transform));
    svg.call(zoom);

    /* ===============================
       node construction unchanged
       =============================== */

    /* ===============================
       generation assignment unchanged
       =============================== */

    const pillHeight = 30;
    const standardPillWidth = 160;
    const maxGen = Math.max(...nodes.map(n => n.generation));
    const columnWidth = Math.max(width / (maxGen + 1), standardPillWidth * 1.6);

    /* ========================================
       ðŸ”½ MAIN CHANGE: generation layout loop
       ======================================== */
    for (let gen = 0; gen <= maxGen; gen++) {
        let genNodes = nodes.filter(n => n.generation === gen);

        if (gen >= 2) {
            genNodes.sort(customSortColumnByParents);
        }

        let yOffset = 0;
        const visible = genNodes.filter(n => !n.variant);
        const totalHeight =
            visible.length * (pillHeight + 16) +
            genNodes.filter(n => n.variant).length * (pillHeight + 2);

        const startY = (height - totalHeight) / 2;

        genNodes.forEach(node => {
            node.x = gen * columnWidth;

            if (!node.variant) {
                node.y = startY + yOffset;
                yOffset += pillHeight + 16;

                const variants = nodes
                    .filter(v => v.variant === node.name)
                    .sort((a, b) => a.name.localeCompare(b.name));

                variants.forEach((v, i) => {
                    v.x = node.x;
                    v.y = node.y + (i + 1) * (pillHeight + 2);
                });

                yOffset += variants.length * (pillHeight + 2);
            }
        });
    }

    /* ===============================
       column 1 adjustment unchanged
       =============================== */

    /* ===============================
       rendering unchanged
       =============================== */
};

/* ===============================
   data fetch unchanged
   =============================== */
</script>
</body>
</html>
