<!-- === HEAD START === -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WeedTree.fyi Strain Lineage Chart</title>
    <base href="https://www.weedtree.fyi">

    <!-- Counter -->
    <script src="https://cdn.counter.dev/script.js" 
            data-id="c89e409b-c7ae-4e59-8da1-bf5116b65993" 
            data-utcoffset="13"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXX');
    </script>

    <!-- D3 Library -->
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="styles.css">
</head>
<!-- === HEAD END === -->

<!-- === BODY START === -->
<body>
    <div class="header-ribbon">
        <h1>
            WeedTree.fyi Strain Lineage Chart
            <span class="subhead">Work in progress, errors probable</span>
        </h1>

        <div class="header-buttons">
            <div class="search-container">
                <input type="text" placeholder="Search strains..." />
            </div>
        </div>
    </div>

    <div id="chart-container"></div>

    <div class="info-panel">
        <h2>Welcome to Weedtree, the family tree of cannabis strains</h2>
        <p>
            I've always wondered how strain lineage correlated with the strains I personally prefer.
            Indica vs Sativa, Kush vs Afghani, Skunk vs Thai. I haven't been able to find much of a
            lineage chart anywhere online so decided to create one myself.
        </p>
        <p>
            I don't claim that the chart is completely accurate; it is based on what I could interpret
            from the multitude of, often contradictory, strain database sites internationally, and I've
            made some simplifications around phenotype/cultivar/clone/variant pedigree. Obviously it
            is far from complete.
        </p>
        <p>
            Push F11 to toggle full screen.<br>
            Use the mouse or controls to zoom in and out.<br>
            Nodes are draggable within their column (press shift / long press on mobile).<br>
            Click on a strain to isolate its lineage.
        </p>
        <p>
            Isolation mode shows rough percentage of contribution based on lineage, but will be
            inaccurate as it does not account for the realities and nuances of selective breeding.
        </p>
        <p>
            Sorry it's a bit hard to use on mobile, best on a large screen. Strain search isn't
            working on mobile at the moment either.
        </p>
        <p>Loading strain data, please wait...</p>
    </div>
</body>
<!-- === BODY END === -->

<script>

let strainData = [], attributes = [], nodes = [], svg, g, zoom, focusedNode = null, lineWidth = 2;
const nodePillHeight = 30;
const nodeStrokeWidth = 3;
const nodeStrokeColor = '#000';
const nodeTextYOffset = 1;
const showError = (message) => {
    document.getElementById('loading-message').style.display = 'none';
    alert(message);
};
    
fetch('https://docs.google.com/spreadsheets/d/e/2PACX-1vSoTjN6psMidKhKOaAxqcZQQ_ArKkUTuRgn65c3ncNqjdLASER0J-Z3WYxFNuhFX_gDVoyHyH1PcCZy/pub?output=csv&gid=1070299978')
    .then(response => {
        if (!response.ok) throw new Error("Network response was not ok");
        return response.text();
    })
    .then(csvText => {
        const rows = csvText.trim().split('\n').map(row => row.split(',').map(cell => cell.trim()));
        if (rows.length < 2) {
            showError("Not enough data in the spreadsheet.");
            return;
        }

        attributes = rows[0];
        strainData = rows.slice(1).map(row => {
            let obj = {};
            attributes.forEach((attr, index) => {
                obj[attr] = row[index] || '';
            });
            return obj;
        }).filter(obj => Object.values(obj).some(value => value !== ''));

        document.getElementById('loading-message').style.display = 'none';
        createLineageChart();
        setupStrainSearch();
    })
    .catch(error => {
        showError("Error fetching data: " + error.message);
        console.error("Fetch error:", error);
    });

function populateStrainList() {
    const strainList = document.getElementById('strainList');
    strainList.innerHTML = '';

    const sortedStrains = nodes
        .filter(strain => !strain.name.toLowerCase().includes('unknown'))
        .sort((a, b) => a.name.localeCompare(b.name));

    sortedStrains.forEach(strain => {
        const strainItem = document.createElement('div');
        strainItem.className = 'strain-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `strain-${strain.id}`;
        checkbox.className = 'strain-checkbox';

        const label = document.createElement('label');
        label.htmlFor = `strain-${strain.id}`;
        label.className = 'strain-label';
        label.textContent = strain.name + (strain.product ? ` (${strain.product})` : '');

        strainItem.appendChild(checkbox);
        strainItem.appendChild(label);
        strainList.appendChild(strainItem);
    });
}

function customSortColumn2(a, b) {
    const dominanceOrder = {
        'indica dominant': 0,
        'ruderalis dominant': 1,
        'balanced hybrid': 2,
        'unknown': 3,
        'sativa dominant': 4
    };

    const indicaOrder = [
        'Afghan/Pakistan Indica Landraces',
        'Purple Afghan Indica Landraces',
        'Hindu Kush Landraces',
        'Nepalese Indica Landraces',
        'North American Indica Landraces'
    ];

    const sativaOrder = [
        'South India Sativa Landraces',
        'Burmese Sativa Landraces',
        'Cambodia Sativa Landraces',
        'Thai Sativa Landraces',
        'Chocolate Thai Sativa Landraces',
        'Purple Thai Sativa Landraces',
        'Indonesia Sativa Landraces',
        'North African Sativa Landraces',
        'East African Sativa landraces',
        'South African Sativa Landraces',
        'Jamaican Sativa Landraces',
        'California Sativa Landraces',
        'Mexico Sativa Landraces',
        'Panama Sativa Landraces',
        'Colombian Sativa Landraces',
        'Brazil Sativa Landraces',
        'Hawaiian Sativa Landraces'
    ];

    if (a.dominance.toLowerCase() !== b.dominance.toLowerCase()) {
        return dominanceOrder[a.dominance.toLowerCase()] - dominanceOrder[b.dominance.toLowerCase()];
    }

    if (a.dominance.toLowerCase() === 'indica dominant') {
        const aIndex = indicaOrder.indexOf(a.name);
        const bIndex = indicaOrder.indexOf(b.name);
        
        if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
        }
        if (aIndex !== -1) return -1;
        if (bIndex !== -1) return 1;
    }

    if (a.dominance.toLowerCase() === 'sativa dominant') {
        const aIndex = sativaOrder.indexOf(a.name);
        const bIndex = sativaOrder.indexOf(b.name);

        if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
        if (aIndex !== -1) return -1;
        if (bIndex !== -1) return 1;
    }

    // Default to alphabetical sorting
    return a.name.localeCompare(b.name);
}

function customSortColumn3Plus(a, b) {
    const dominanceOrder = {
        'indica dominant': 0,
        'balanced hybrid': 1,
        'unknown': 2,
        'sativa dominant': 3
    };

    if (a.dominance.toLowerCase() !== b.dominance.toLowerCase()) {
        return dominanceOrder[a.dominance.toLowerCase()] - dominanceOrder[b.dominance.toLowerCase()];
    }

    return a.name.localeCompare(b.name);
}

function barycentricSort(genNodes, nodes, direction = 'parents') {
    return genNodes
        .map(n => {
            let refs = [];

            if (direction === 'parents') {
                refs = n.parents
                    .map(pid => nodes.find(p => p.id === pid))
                    .filter(Boolean);
            } else {
                refs = nodes.filter(c => c.parents.includes(n.id));
            }

            const avgY = refs.length
                ? d3.mean(refs, r => r.y)
                : n.y;

            return { node: n, avgY };
        })
        .sort((a, b) => {
            if (a.avgY == null && b.avgY == null) return 0;
            if (a.avgY == null) return 1;
            if (b.avgY == null) return -1;
            return a.avgY - b.avgY;
        })
        .map(d => d.node);
}
 
function calculateColumn1Positions() {
    const column1Nodes = nodes.filter(n => n.generation === 0);
    column1Nodes.forEach(node => {
        const children = nodes.filter(n => n.parents.includes(node.id));
        if (children.length > 0) {
            const avgY = d3.mean(children, d => d.y);
            node.y = avgY;
        }
    });
}

function formatPercentage(p) {
    const capped = Math.min(p, 100);  // limit to 100
    return capped < 5 ? '<5%' : `${capped.toFixed(0)}%`;
}


function calculateUpwardChildTotals(startNode, nodes) {
    const contributions = new Map();

    function walk(node, amount) {
        contributions.set(
            node.id,
            (contributions.get(node.id) || 0) + amount
        );

        let parents = [];

        if (node.parents && node.parents.length > 0) {
            parents = node.parents
                .map(pid => nodes.find(n => n.id === pid))
                .filter(Boolean);
        }

        if (node.variant) {
            const base = nodes.find(n => n.name === node.variant);
            if (base) parents.push(base);
        }

        if (parents.length === 0) return;

        const split = amount / parents.length;

        parents.forEach(parent => {
            walk(parent, split);
        });
    }

    walk(startNode, 100);
    return contributions;
}


function calculateDownwardDescendantTotals(startNode, nodes) {
    const contributions = new Map();

    function walk(node, amount) {
        // Do not store the focused node itself
        if (node.id !== startNode.id) {
            contributions.set(
                node.id,
                (contributions.get(node.id) || 0) + amount
            );
        }

        // Find children (normal + variants)
        const children = nodes.filter(n =>
            (n.parents && n.parents.includes(node.id)) ||
            n.variant === node.name
        );

        children.forEach(child => {
            let parentCount = 0;

            if (child.parents && child.parents.length > 0) {
                parentCount += child.parents.length;
            }

            if (child.variant) {
                parentCount += 1;
            }

            if (parentCount === 0) return;

            const split = amount / parentCount;
            walk(child, split);
        });
    }

    walk(startNode, 100);
    return contributions;
}


const createLineageChart = () => {
    const chartContainer = document.querySelector('.chart-container');
    const width = chartContainer.clientWidth, height = chartContainer.clientHeight;
    d3.select("#lineageChart").selectAll("*").remove();
    svg = d3.select("#lineageChart").append("svg").attr("width", width).attr("height", height);
    g = svg.append("g");
    zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => g.attr("transform", event.transform));
    svg.call(zoom);
    
    nodes = strainData.map(strain => ({
        id: strain.Strain,
        name: strain.Strain,
        displayName: strain.Strain,
        dominance: strain.Dominance,
        parents: [strain.Parent1, strain.Parent2, strain.Parent3, strain.Parent4].filter(p => p),
        generation: 0,
        special: strain.Special,
        product: strain.Product,
        variant: strain.Variant,
        alsoKnownAs: strain['Also Known As']
    }));

    const hasChildren = new Set(nodes.flatMap(node => node.parents));
    nodes = nodes.filter(node => 
        hasChildren.has(node.name) || node.parents.length > 0 || node.special || node.variant
    );

    nodes.forEach(node => {
        if (node.name.toLowerCase().includes('unknown')) {
            node.displayName = node.name.replace(/\d+/g, '');
        }
    });

    nodes.sort((a, b) => {
        if (a.product && !b.product) return 1;
        if (!a.product && b.product) return -1;
        return 0;
    });

    const links = [];
    nodes.forEach(node => {
        if (node.variant) {
            const parentNode = nodes.find(n => n.name === node.variant);
            if (parentNode) links.push({ source: parentNode.id, target: node.id });
        } else {
            node.parents.forEach(parent => {
                if (parent && nodes.some(n => n.id === parent)) links.push({ source: parent, target: node.id });
            });
        }
    });

    const assignGenerations = () => {
        let changed = true;
        while (changed) {
            changed = false;
            nodes.forEach(node => {
                if (node.name.toLowerCase().includes('unknown lineages')) {
                    if (node.generation !== 2) {  
                        node.generation = 2;
                        changed = true;
                    }
                } else if (node.special && node.special.toLowerCase() === 'origin') {
                    if (node.generation !== 0) {
                        node.generation = 0;
                        changed = true;
                    }
                } else if (node.special && node.special.toLowerCase() === 'landrace') {
                    if (node.generation !== 1) {
                        node.generation = 1;
                        changed = true;
                    }
                } else if (node.variant) {
                    const parentNode = nodes.find(n => n.name === node.variant);
                    if (parentNode && node.generation !== parentNode.generation) {
                        node.generation = parentNode.generation;
                        changed = true;
                    }
                } else {
                    if (node.name.toLowerCase().includes('unknown') && !node.name.toLowerCase().includes('unknown lineages')) {
                        if (node.generation < 2) {  
                            node.generation = 2;
                            changed = true;
                        }
                    } else {
                        const parentGens = node.parents.map(parentId => {
                            const parent = nodes.find(n => n.id === parentId);
                            return parent ? parent.generation : -1;
                        }).filter(gen => gen !== -1);
                        if (parentGens.length > 0) {
                            const maxParentGen = Math.max(...parentGens);
                            if (node.generation !== maxParentGen + 1) {
                                node.generation = maxParentGen + 1;
                                changed = true;
                            }
                        }
                    }
                }
            });
        }

        let specialCaseChanged = true;
        while (specialCaseChanged) {
            specialCaseChanged = false;
            nodes.forEach(node => {
                if (!node.name.toLowerCase().includes('unknown lineages') &&
                    (node.name.toLowerCase().includes('unknown') || 
                    (node.parents.length > 0 && node.parents.every(parentId => {
                        const parent = nodes.find(n => n.id === parentId);
                        return parent && parent.name.toLowerCase().includes('unknown');
                    })))) {
                    const children = nodes.filter(n => n.parents.includes(node.id));
                    if (children.length > 0) {
                        const minChildGen = Math.min(...children.map(c => c.generation));
                        const newGen = Math.max(2, minChildGen - 1); // Ensure minimum generation is 2
                        if (node.generation !== newGen) {
                            node.generation = newGen;
                            specialCaseChanged = true;
                        }
                    }
                }
            });
        }
    };
    assignGenerations();

    const maxWidth = Math.max(...nodes.map(d => d.displayName.length * 7));
    const standardPillWidth = Math.max(maxWidth, 150);
    const pillHeight = 30; 
    const maxGeneration = Math.max(...nodes.map(n => n.generation));
    const columnWidth = Math.max(width / (maxGeneration + 1), standardPillWidth * 1.6);

    const column2Nodes = nodes.filter(n => n.generation === 1 && !n.variant);
    column2Nodes.sort(customSortColumn2);

    for (let gen = 0; gen <= maxGeneration + 1; gen++) {
        let genNodes = nodes.filter(n => 
            (n.generation === gen) || 
            (gen === 1 && n.special && n.special.toLowerCase() === 'landrace')
        );

        if (gen === 1) {
            genNodes = column2Nodes.concat(genNodes.filter(n => !column2Nodes.includes(n)));
   } else if (gen >= 2) {

    genNodes.sort(customSortColumn3Plus);
}

        let yOffset = 0;
        const totalHeight = genNodes.filter(n => !n.variant).length * (pillHeight + 10) +
                            genNodes.filter(n => n.variant).length * (pillHeight + 2);
        const startY = (height - totalHeight) / 2;

        genNodes.forEach((node, index) => {
            node.x = gen * columnWidth; // Set x position based on generation
            if (!node.variant) {
                if (gen !== 0 || node.y === undefined) {
                    node.y = startY + yOffset;
                }
                yOffset += pillHeight + 16; // min gap between standard nodes

                const variants = nodes.filter(n => n.variant === node.name).sort((a, b) => a.name.localeCompare(b.name));
                variants.forEach((variant, vIndex) => {
                    variant.y = node.y + (vIndex + 1) * (pillHeight + 2);
                    variant.x = node.x;
                });

                yOffset += variants.length * (pillHeight + 2);
            }
        });

if (gen >= 2) {
    genNodes = barycentricSort(genNodes, nodes, 'parents');

    // Re-assign Y positions after barycentric sort
    yOffset = 0;
    genNodes.forEach(node => {
        if (!node.variant) {
            node.y = startY + yOffset;
            yOffset += pillHeight + 16;

            const variants = nodes.filter(n => n.variant === node.name)
                .sort((a, b) => a.name.localeCompare(b.name));

            variants.forEach((variant, vIndex) => {
                variant.y = node.y + (vIndex + 1) * (pillHeight + 2);
            });

            yOffset += variants.length * (pillHeight + 2);
        }
    });
}
    }


    calculateColumn1Positions();

    const link = g.append("g")
        .selectAll("path")
        .data(links)
        .join("path")
        .attr("class", "link")
        .attr("stroke", d => darkenColor(getColorByDominance(nodes.find(n => n.id === d.source).dominance), 2)) 
        .attr("stroke-opacity", 1)
        .attr("stroke-width", lineWidth + 1) 
        .attr("fill", "none")
        .attr("d", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            const sourcePillWidth = sourceNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
            const targetPillWidth = targetNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
            const sourceX = sourceNode.x + sourcePillWidth / 2;
            const targetX = targetNode.x - targetPillWidth / 2;
            const midX = (sourceX + targetX) / 2;
            return `M${sourceX},${sourceNode.y} C${midX},${sourceNode.y} ${midX},${targetNode.y} ${targetX},${targetNode.y}`;
        });

let dragging = false; 

const node = g.append("g")
    .selectAll("g")
    .data(nodes)
    .join("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${d.x},${d.y})`)
    .each(function(d) { if (d.product) d3.select(this).raise(); })
    .on("click", highlightLineage)
    .on("mouseover", function(event, d) {
        if (dragging) return; // prevent hover expansion while dragging
        highlightHoverLineage(event, d);
        d3.select(this).raise()
            .transition()
            .attr("transform", `translate(${d.x},${d.y}) scale(1.7, 1.7)`);
    })
    .on("mouseout", function(event, d) {
        if (dragging) return;
        removeHighlightHoverLineage();
        d3.select(this).transition()
            .attr("transform", `translate(${d.x},${d.y}) scale(1)`);
        g.selectAll(".node").each(function(d) { if (d.product) d3.select(this).raise(); });
    });

// --- DRAGGING with long press on mobile + shift key for desktop ---
node.call(d3.drag()
    .on("start", function(event, d) {
        // Mobile: skip immediate drag, use long press
        if (event.sourceEvent.type.startsWith("touch")) {
            d.longPressTimer = setTimeout(() => {
                startDrag(event, d, this);
            }, 400); // 400ms long press
        } else {
            // Desktop: only start drag if Shift is held
            if (!event.sourceEvent.shiftKey) return;
            startDrag(event, d, this);
        }
    })
    .on("drag", function(event, d) {
        if (!d.dragging) return; 
        dragNode(event, d, this);
    })
    .on("end", function(event, d) {
        if (d.longPressTimer) {
            clearTimeout(d.longPressTimer);
            d.longPressTimer = null;
        }
        if (!d.dragging) return;
        d.dragging = false;
        dragging = false;
    })
);



// --- Helper functions ---
function startDrag(event, d, nodeElement) {
    dragging = true;
    d.dragging = true;
    d3.select(nodeElement).raise();

    // store offsets for variants
    d.variantOffsets = nodes.filter(n => n.variant === d.name)
        .map(v => ({ id: v.id, offsetY: v.y - d.y }));
}

function dragNode(event, d, nodeElement) {
    d.y = event.y;
    d3.select(nodeElement).attr("transform", `translate(${d.x},${d.y})`);

    // move variants with stored offsets
    if (d.variantOffsets) {
        d.variantOffsets.forEach(vo => {
            const variantNode = nodes.find(n => n.id === vo.id);
            variantNode.y = d.y + vo.offsetY;
            g.selectAll(".node")
                .filter(n => n.id === variantNode.id)
                .attr("transform", `translate(${variantNode.x},${variantNode.y})`);
        });
    }

    g.selectAll('.pct-pill')
        .filter(p => nodes.find(n => n.id === p.nodeId) === d || (d.variantOffsets && d.variantOffsets.some(vo => vo.id === p.nodeId)))
        .attr("transform", p => {
            const nodeRef = nodes.find(n => n.id === p.nodeId);
            return `translate(${nodeRef.x},${nodeRef.y})`;
        });

    g.selectAll('.pct-pill-text')
        .filter(p => nodes.find(n => n.id === p.nodeId) === d || (d.variantOffsets && d.variantOffsets.some(vo => vo.id === p.nodeId)))
        .attr("transform", p => {
            const nodeRef = nodes.find(n => n.id === p.nodeId);
            return `translate(${nodeRef.x},${nodeRef.y})`;
        });

    g.selectAll(".link").attr("d", l => {
        const sourceNode = nodes.find(n => n.id === l.source);
        const targetNode = nodes.find(n => n.id === l.target);
        const sourcePillWidth = sourceNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
        const targetPillWidth = targetNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
        const sourceX = sourceNode.x + sourcePillWidth / 2;
        const targetX = targetNode.x - targetPillWidth / 2;
        const midX = (sourceX + targetX) / 2;
        return `M${sourceX},${sourceNode.y} C${midX},${sourceNode.y} ${midX},${targetNode.y} ${targetX},${targetNode.y}`;
    });
}

    node.append("rect")
        .attr("rx", pillHeight / 2)
        .attr("ry", pillHeight / 2)
        .attr("width", d => d.variant ? standardPillWidth * 0.85 : standardPillWidth)
        .attr("height", pillHeight)
        .attr("fill", d => {
            if (d.variant) {
                // Find parent node
                const parentNode = nodes.find(n => n.name === d.variant);
                if (parentNode) {
                    // Get parent's color and blend it towards white
                    const parentColor = getColorByDominance(parentNode.dominance);
                    return blendToWhite(parentColor, 0.5); // Using 0.2 for 20% blend to white
                }
            }
            return getColorByDominance(d.dominance);
        })
        .attr("x", d => d.variant ? -(standardPillWidth * 0.85) / 2 : -standardPillWidth / 2)
        .attr("y", -pillHeight / 2)
        .attr("stroke", d => d.product ? "black" : getColorByDominance(d.dominance))
        .attr("stroke-width", d => d.product ? 3 : 3);

    node.append("text")
        .attr("class", "strain-name")
        .text(d => d.displayName)
        .attr("x", d => d.variant ? -(standardPillWidth * 0.85) / 2 + 12 : -standardPillWidth / 2 + 12) 
        .attr("y", 1)
        .attr("dominant-baseline", "middle")
        .attr("fill", "black")
        .style("font-size", "15px")
        .style("font-family", "'Roboto', Arial, sans-serif")
        .style("font-weight", "bold")
        .each(function(d) {
            // Get the actual width of the strain name and node
            const textWidth = this.getComputedTextLength();
            const nodeWidth = d.variant ? standardPillWidth * 0.85 : standardPillWidth;
            const availableWidth = nodeWidth - 24; // Account for padding
            
            // If text is too long, switch to condensed font
            if (textWidth > availableWidth) {
                d3.select(this)
                    .style("font-family", "'Roboto Condensed', Arial, sans-serif");
                
                // Check if it's still too long with condensed font
                const condensedWidth = this.getComputedTextLength();
                if (condensedWidth > availableWidth) {
                    // Could add additional handling here if needed
                }
            }
        });

    node.append("text")
        .filter(d => d.product)
        .text(d => d.product)
        .attr("class", "product")
        .attr("x", function(d) {
            const strainNameText = this.parentNode.querySelector('.strain-name');
            const strainNameWidth = strainNameText.getComputedTextLength();
            const nodeWidth = d.variant ? standardPillWidth * 0.85 : standardPillWidth;
            return -nodeWidth / 2 + 5 + strainNameWidth + 10;
        })
        .attr("y", 1.6)
        .attr("dominant-baseline", "middle")
        .attr("fill", "black")
        .style("font-size", "10px")
        .style("font-family", "'Roboto', Arial, sans-serif")
        .style("font-weight", "normal")
        .each(function(d) {
            const textWidth = this.getComputedTextLength();
            const nodeWidth = d.variant ? standardPillWidth * 0.85 : standardPillWidth;
            const strainNameText = this.parentNode.querySelector('.strain-name');
            const remainingWidth = nodeWidth - strainNameText.getComputedTextLength() - 40;
            
            if (textWidth > remainingWidth) {
                // Apply condensed font to product text
                d3.select(this).style("font-family", "'Roboto Condensed', Arial, sans-serif");
                
                // Apply condensed font to strain name if not already condensed
                d3.select(this.parentNode).select('.strain-name')
                    .style("font-family", "'Roboto Condensed', Arial, sans-serif");
                
                // Reposition product text based on new strain name width
                const newStrainNameWidth = strainNameText.getComputedTextLength();
                d3.select(this).attr("x", -nodeWidth / 2 + 5 + newStrainNameWidth + 10);
            }
        });

    node.filter(d => d.product)
        .append("use")
        .attr("xhref", "#nzIcon")
        .attr("width", 30)
        .attr("height", 30)
        .attr("x", function(d) {
            const nodeWidth = d.variant ? standardPillWidth * 0.85 : standardPillWidth;
            return nodeWidth / 2 - 20; 
        })
        .attr("y", -14);


    
    function highlightLineage(event, d) {

    // Remove old percentage pills
    g.selectAll('.pct-pill').remove();
    g.selectAll('.pct-pill-text').remove();

   if (focusedNode === d) {

    g.selectAll('.pct-pill').remove();
    g.selectAll('.pct-pill-text').remove();

    node.classed("dimmed", false);
    node.classed("clicked", false);
    link.classed("dimmed", false)
        .attr("stroke-width", lineWidth + 1);

    focusedNode = null;
    resetZoom();
    return;
}

    const lineage = new Set();

    const getAncestors = (node) => {
    lineage.add(node.id);

if (node.variant) {
    const base = nodes.find(n => n.name === node.variant);
    if (base) {
        lineage.add(base.id);
        getAncestors(base);
    }
    return;
}

    node.parents.forEach(parentId => {
        const parent = nodes.find(n => n.id === parentId);
        if (parent) {
            lineage.add(parent.id);
            getAncestors(parent);
        }
    });
};


 const getDescendants = (nodeId) => {
    lineage.add(nodeId);
    
    const children = nodes.filter(n => n.parents.includes(nodeId));
    
    const variantChildren = nodes.filter(n => n.variant === nodes.find(nd => nd.id === nodeId).name);
    
    const allChildren = [...children, ...variantChildren];
    
    allChildren.forEach(child => {
        if (!lineage.has(child.id)) {  
            lineage.add(child.id);
            getDescendants(child.id);
        }
    });
};


    getAncestors(d);
    getDescendants(d.id);

    node.classed("dimmed", n => !lineage.has(n.id));
    node.classed("clicked", n => n.id === d.id);
    link.classed("dimmed", l => !lineage.has(l.source) || !lineage.has(l.target))
        .attr("stroke-width", l =>
            (lineage.has(l.source) && lineage.has(l.target))
                ? lineWidth + 2
                : lineWidth + 1
        );

    focusedNode = d;
    zoomToLineage(lineage);
        
const contributionStartNode = d;

const ancestorContrib = calculateUpwardChildTotals(
    contributionStartNode,
    nodes
);

const descendantContrib = calculateDownwardDescendantTotals(
    contributionStartNode,
    nodes
);

const contributions = new Map();

ancestorContrib.forEach((v, k) => {
    contributions.set(k, v);
});

descendantContrib.forEach((v, k) => {
    contributions.set(k, (contributions.get(k) || 0) + v);
});

contributions.set(contributionStartNode.id, 100);


g.selectAll('.node')
  .filter(n => contributions.has(n.id) && n.id !== contributionStartNode.id)
  .each(function(n) {

    const pct = contributions.get(n.id);
    const label = formatPercentage(pct);

    const group = d3.select(this);

    const nodeWidth = n.variant ? standardPillWidth * 0.85 : standardPillWidth;
    const pillHeight = nodePillHeight;
    const pillPaddingX = 10;
    const pillWidth = 80;
    const pillX = nodeWidth / 2;

    group.insert('rect', ':first-child') // insert behind everything in this node
      .attr('class', 'pct-pill')
      .attr('x', pillX - pillPaddingX *2 - 4 )
      .attr('y', -pillHeight / 2)
      .attr('rx', pillHeight / 2)
      .attr('ry', pillHeight / 2)
      .attr('width', pillWidth)
      .attr('height', pillHeight)
      .attr('fill', 'white')
      .attr('stroke', nodeStrokeColor)
      .attr('stroke-width', nodeStrokeWidth);

    group.append('text')
      .attr('class', 'pct-pill-text')
      .attr('x', nodeWidth / 2 + pillPaddingX)  
      .attr('y', 1)
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .text(label)
      .style('fill', 'white')
      .style('pointer-events', 'none');
  });
}


    function highlightHoverLineage(event, d) {
        const lineage = new Set();
        const getAncestors = (node) => {
            lineage.add(node.id);
            if (node.variant) {
                const parentNode = nodes.find(n => n.name === node.variant);
                if (parentNode) {
                    lineage.add(parentNode.id);
                    getAncestors(parentNode);
                }
            } else {
                node.parents.forEach(parentId => {
                    const parent = nodes.find(n => n.id === parentId);
                    if (parent) {
                        lineage.add(parentId);
                        getAncestors(parent);
                    }
                });
            }
        };
        const getDescendants = (nodeId) => {
            lineage.add(nodeId);
            const children = nodes.filter(n => n.parents.includes(nodeId) || (n.variant === nodes.find(node => node.id === nodeId).name));
            children.forEach(child => {
                lineage.add(child.id);
                getDescendants(child.id);
            });
        };
        getAncestors(d);
        getDescendants(d.id);
        node.classed("highlighted", n => lineage.has(n.id));
        link.classed("highlighted", l => lineage.has(l.source) && lineage.has(l.target));
    }

    function removeHighlightHoverLineage() {
        node.classed("highlighted", false);
        link.classed("highlighted", false);
    }

    function zoomToLineage(lineage) {
        const activeNodes = nodes.filter(n => lineage.has(n.id));
        const minX = d3.min(activeNodes, n => n.x) - standardPillWidth / 2;
        const maxX = d3.max(activeNodes, n => n.x) + standardPillWidth / 2;
        const minY = d3.min(activeNodes, n => n.y) - pillHeight / 2;
        const maxY = d3.max(activeNodes, n => n.y) + pillHeight / 2;
        const padding = 50;

        const scale = Math.min(
            width / (maxX - minX + 2 * padding),
            height / (maxY - minY + 2 * padding)
        );

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const translate = [
            width / 2 - scale * centerX,
            height / 2 - scale * centerY
        ];

        svg.transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity
                .translate(translate[0], translate[1])
                .scale(scale));
    }

    function resetZoom() {
        svg.transition()
            .duration(750)
            .call(zoom.transform, calculateInitialTransform());
    }

    function calculateInitialTransform() {
        const padding = 50;
        const minX = d3.min(nodes, n => n.x) - standardPillWidth / 2;
        const maxX = d3.max(nodes, n => n.x) + standardPillWidth / 2;
        const minY = d3.min(nodes, n => n.y) - pillHeight / 2;
        const maxY = d3.max(nodes, n => n.y) + pillHeight / 2;

        const scale = Math.min(
            width / (maxX - minX + 2 * padding),
            height / (maxY - minY + 2 * padding)
        );

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const translateX = width / 2 - scale * centerX;
        const translateY = height / 2 - scale * centerY;

        return d3.zoomIdentity
            .translate(translateX, translateY)
            .scale(scale);
    }

    const initialTransform = calculateInitialTransform();
    svg.call(zoom.transform, initialTransform);

    populateStrainList();

(function autoFocusFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    let focusStrain = urlParams.get('focus');
    if (!focusStrain) return;

    focusStrain = focusStrain.replace(/_/g, ' ').replace(/\s+/g, ' ').trim().toLowerCase();

    requestAnimationFrame(() => {
        const targetNode = nodes.find(n => {
            const nodeName = n.name.replace(/\s+/g, ' ').trim().toLowerCase();
            return nodeName === focusStrain;
        });
        if (!targetNode) return;

        console.log("Focusing on strain:", targetNode.name);

        highlightLineage(null, targetNode);

        const lineageNodes = getLineageNodes(targetNode); // all highlighted nodes
        const xValues = lineageNodes.map(n => n.x);
        const yValues = lineageNodes.map(n => n.y);

        const minX = Math.min(...xValues);
        const maxX = Math.max(...xValues);
        const minY = Math.min(...yValues);
        const maxY = Math.max(...yValues);

        const chartWidth = document.querySelector('.chart-container').clientWidth;
        const chartHeight = document.querySelector('.chart-container').clientHeight;

        const padding = 50; // space around the lineage
        const scaleX = (chartWidth - padding) / (maxX - minX || 1);
        const scaleY = (chartHeight - padding) / (maxY - minY || 1);
        let scale = Math.min(scaleX, scaleY);

        const minScale = 0.8;
        const maxScale = 2.5;
        scale = Math.max(minScale, Math.min(maxScale, scale));

        const translateX = chartWidth / 2 - ((minX + maxX) / 2) * scale;
        const translateY = chartHeight / 2 - ((minY + maxY) / 2) * scale;

        svg.transition()
            .duration(600)
            .call(
                zoom.transform,
                d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale)
            );
    });
})();

};



    
const getColorByDominance = (dominance) => {
    switch(dominance.toLowerCase()) {
        case 'sativa dominant': return '#ffea8a';
        case 'indica dominant': return '#9be7f5';
        case 'ruderalis dominant': return '#d9d2e9';    
        case 'balanced hybrid': return '#bee8a6';
        case 'unknown': return '#d1e6cb';
        default: return '#EAEAEA';
    }
};

const darkenColor = (color, amount) => d3.color(color).darker(amount / 10).toString();
const blendToWhite = (color, amount) => {
    const baseColor = d3.color(color);
    const whiteColor = d3.color("#ffffff");
    const interpolatedColor = d3.interpolateRgb(baseColor, whiteColor)(amount);
    return interpolatedColor;
};

function setupStrainSearch() {
    const searchInput = document.getElementById('strainSearch');
    const dropdown = document.getElementById('strainDropdown');
    let highlightedNode = null;

    searchInput.addEventListener('input', function() {
        const searchText = this.value.toLowerCase();
        if (searchText.length === 0) {
            dropdown.style.display = 'none';
            return;
        }

        const matchingStrains = nodes.filter(node => 
            !node.name.toLowerCase().includes('unknown') && (
                node.name.toLowerCase().includes(searchText) ||
                (node.product && node.product.toLowerCase().includes(searchText)) ||
                (node.alsoKnownAs && node.alsoKnownAs.toLowerCase().includes(searchText))
            )
        );

        dropdown.innerHTML = '';
        matchingStrains.sort((a, b) => a.name.localeCompare(b.name)).forEach(strain => {
            const div = document.createElement('div');
            div.innerHTML = strain.name + 
                            (strain.product ? `<br>(${strain.product})` : '') + 
                            (strain.alsoKnownAs ? ` [${strain.alsoKnownAs}]` : '');
            div.addEventListener('click', () => {
                highlightStrain(strain);
                dropdown.style.display = 'none';
                searchInput.value = '';
            });
            dropdown.appendChild(div);
        });

        dropdown.style.display = matchingStrains.length > 0 ? 'block' : 'none';
    });

    document.addEventListener('click', function(event) {
        if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
            dropdown.style.display = 'none';
        }
    });

    function highlightStrain(strain) {
        if (highlightedNode) {
            d3.select(highlightedNode).select('.highlight-arrow').remove();
            highlightedNode = null;
        }

        const node = g.selectAll('.node').filter(d => d.id === strain.id);
        const arrow = node.append('path')
            .attr('d', 'M-70,-6 L-39,0 L-70,6 Z')
            .attr('class', 'highlight-arrow')
            .attr('fill', 'red')
            .attr('transform', 'translate(0,0) scale(3)');

        arrow.on('mouseover', function() {
            d3.select(this).remove();
            highlightedNode = null;
        });

        arrow.on('click', function(event) {
            event.stopPropagation();
        });

        highlightedNode = node.node();

        zoomToNode(strain);
    }

    function zoomToNode(strain) {
        const transform = d3.zoomTransform(svg.node());
        const scale = 2;
        const x = -strain.x * scale + svg.attr('width') / 2;
        const y = -strain.y * scale + svg.attr('height') / 2;

        svg.transition()
            .duration(750)
            .call(d3.zoom().transform, d3.zoomIdentity.translate(x, y).scale(scale));
    }
}
    
window.addEventListener('load', function() {
    const aboutBtn = document.getElementById('btn3');
    const popup3 = document.getElementById('popup3');
    const overlay = document.querySelector('.popup-overlay');
    if (aboutBtn && popup3 && overlay) {
        aboutBtn.addEventListener('click', () => {
            popup3.style.display = 'block';
            overlay.style.display = 'block';
        });
        popup3.style.display = 'block';
        overlay.style.display = 'block';
    }
});

document.querySelectorAll('.close-button').forEach(button => {
    button.addEventListener('click', function() {
        const popup = this.closest('.popup');
        popup.style.display = 'none';
        document.querySelector('.popup-overlay').style.display = 'none';
    });
});

document.getElementById('fullscreenToggle').addEventListener('click', toggleFullScreen);
document.getElementById('zoomInButton').addEventListener('click', () => {
    const currentTransform = d3.zoomTransform(svg.node());
    const newScale = currentTransform.k * 1.05; // Increase zoom by 20%
    
    if (newScale <= zoom.scaleExtent()[1]) { 
        svg.transition()
            .duration(250)
            .call(zoom.transform, 
                d3.zoomIdentity
                    .translate(currentTransform.x, currentTransform.y)
                    .scale(newScale)
            );
    }
});

document.getElementById('zoomOutButton').addEventListener('click', () => {
    const currentTransform = d3.zoomTransform(svg.node());
    const newScale = currentTransform.k / 1.05; // Decrease zoom by 20%
    
    if (newScale >= zoom.scaleExtent()[0]) { 
        svg.transition()
            .duration(250)
            .call(zoom.transform, 
                d3.zoomIdentity
                    .translate(currentTransform.x, currentTransform.y)
                    .scale(newScale)
            );
    }
});

document.getElementById('deselectButton').addEventListener('click', () => {
    if (focusedNode) {

        g.selectAll('.pct-pill').remove();
        g.selectAll('.pct-pill-text').remove();

        g.selectAll(".node")
            .classed("dimmed", false)
            .classed("clicked", false);

        g.selectAll("path.link")
            .classed("dimmed", false)
            .attr("stroke-width", lineWidth + 1);

        focusedNode = null;
        resetZoom();
    }
});


function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

window.addEventListener('resize', function() {
    createLineageChart();
    adjustFullscreenButtonPosition();
    adjustButtonFontSize();
});

function adjustFullscreenButtonPosition() {
    const ribbon = document.querySelector('.header-ribbon');
    const fullscreenButton = document.querySelector('.fullscreen-button-container');
    if (ribbon && fullscreenButton) {
        const ribbonHeight = ribbon.offsetHeight;
        fullscreenButton.style.top = (ribbonHeight + 10) + 'px';
    }
}

function adjustButtonFontSize() {
    const buttons = document.querySelectorAll('.btn:not(#btn3)'); 
    const headerButtons = document.querySelector('.header-buttons');
    
    if (!buttons.length || !headerButtons) {
        return;
    }
    
    const availableWidth = headerButtons.offsetWidth;
    let totalButtonWidth = 0;

    const aboutButton = document.getElementById('btn3');
    const aboutButtonWidth = aboutButton ? aboutButton.offsetWidth : 0;
    
    buttons.forEach(button => {
        if (button) {
            button.style.fontSize = '0.9em'; // Reset to original size
            totalButtonWidth += button.offsetWidth;
        }
    });

    const adjustableWidth = availableWidth - aboutButtonWidth;

    if (totalButtonWidth > adjustableWidth) {
        const scaleFactor = adjustableWidth / totalButtonWidth;
        buttons.forEach(button => {
            if (button) {
                const newSize = parseFloat(getComputedStyle(button).fontSize) * scaleFactor;
                button.style.fontSize = `${newSize}px`;
            }
        });
    }
}

window.addEventListener('load', adjustButtonFontSize);

document.querySelector('.popup-overlay').addEventListener('click', function() {
    document.querySelectorAll('.popup').forEach(popup => popup.style.display = 'none');
    this.style.display = 'none';
});

document.querySelectorAll('.popup').forEach(popup => 
    popup.addEventListener('click', event => event.stopPropagation())
);



    
</script>
</body>
</html>
