<!DOCTYPE html> 
<html>
<head>
<base href="https://www.weedtree.fyi">

<script src="https://cdn.counter.dev/script.js" data-id="c89e409b-c7ae-4e59-8da1-bf5116b65993" data-utcoffset="13"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8527SLLPYV"></script>
<script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-8527SLLPYV'); </script>
<script src="https://d3js.org/d3.v6.min.js"></script>

<title>WeedTree Strain Lineage Chart</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
<link rel="icon" type="image/svg+xml" href='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 850 850"%3E%3Cpath fill="%2391C83E" d="M39.6 362.6C39.6 184.2 210.3 39.6 420.9 39.6c210.5 0 381.2 144.6 381.2 323 0 178.4-170.7 323-381.2 323-210.6 0-381.3-144.6-381.3-323z"/%3E%3Cpath fill="%236FAC43" d="M503.2 266c0-18.6 17.8-33.7 39.7-33.7 22 0 39.7 15.1 39.7 33.7 0 18.6-17.8 33.7-39.7 33.7-22 0-39.7-15.1-39.7-33.7zm-244.2 0c0-18.6 17.8-33.7 39.7-33.7 21.9 0 39.7 15.1 39.7 33.7 0 18.6-17.8 33.7-39.7 33.7-21.9 0-39.7-15.1-39.7-33.7z"/%3E%3Cpath fill="none" stroke="%23444" stroke-width="79.2" d="M503.2 266c0-18.6 17.8-33.7 39.7-33.7 22 0 39.7 15.1 39.7 33.7 0 18.6-17.8 33.7-39.7 33.7-22 0-39.7-15.1-39.7-33.7zm-244.2 0c0-18.6 17.8-33.7 39.7-33.7 21.9 0 39.7 15.1 39.7 33.7 0 18.6-17.8 33.7-39.7 33.7-21.9 0-39.7-15.1-39.7-33.7zm-44.8 237.5c137.8 80.2 275.3 80.2 412.7 0M39.6 362.6C39.6 184.2 210.3 39.6 420.9 39.6c210.5 0 381.2 144.6 381.2 323 0 178.4-170.7 323-381.2 323-210.6 0-381.3-144.6-381.3-323z"/%3E%3C/svg%3E' />
    

<style>
body, html { font-family:'Poppins', Arial, sans-serif; background-color:#fff; margin:0; padding:0; font-size:14px; height:100%; overflow:hidden; }
#centerLine { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; }
.header-ribbon { background-color:#434343; color:#fff; padding:10px; display:flex; justify-content:space-between; align-items:center; }
.header-ribbon h1 { margin:0; font-size:1.8em; color:#fff; margin-left:6px; }
.header-buttons { display:flex; gap:10px; align-items:center; }
.subhead { font-size:.4em; font-weight:400; margin-left:3px; }
.btn { background-color:transparent; color:#fff; padding:5px 15px; border:2px solid #fff; border-radius:18px; cursor:pointer; font-size:0.9em; font-family:'Poppins', Arial, sans-serif; transition:all .3s ease; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.btn:hover { background-color:rgba(255,255,255,.1); }
.popup-overlay { position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,.5); z-index:999; display:none; }
.popup { position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border-radius:10px; max-width:80%; max-height:80%; overflow-y:auto; z-index:1000; display:none; }
#popup1 { padding:0; }
#popup2, #popup3 { padding:20px; }
.search-container { position:relative; }   
#strainSearch { background-color:transparent; color:#fff; padding:5px 15px; border:2px solid #fff; border-radius:18px; font-size:.9em; font-family:'Poppins', Arial, sans-serif; transition:all .3s ease; width:180px; }
#strainSearch::placeholder { color:rgba(255,255,255,0.7); }
#strainSearch:focus { outline:none; background-color:rgba(255,255,255,0.1); }
#strainDropdown { position:absolute; background-color:#fff; border:1px solid #ccc; max-height:400px; overflow-y:auto; display:none; z-index:1000; width:210px; box-shadow:1 4px 8px rgba(0,0,0,0.1); border-radius:0 0 4px 4px; }
#strainDropdown div { padding:5px 10px; cursor:pointer; transition:background-color 0.2s; color:#434343; font-size:8pt; line-height:1.2; }
#strainDropdown div:hover { background-color:#f0f0f; }
.strain-list { column-width:228px; column-gap:5px; padding:10px; max-height:96%; overflow-x:auto; white-space:nowrap; }
.strain-item { display:flex; align-items:center; margin-bottom:0px; break-inside:avoid-column; }
.strain-checkbox { appearance:none; -webkit-appearance:none; width:16px; height:16px; border:2px solid #434343; border-radius:50%; margin-right:5px; cursor:pointer; position:relative; }
.strain-checkbox:checked::after { content:''; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:10px; height:10px; background-color:#434343; border-radius:50%; }
.strain-checkbox:hover { background-color:#f0f0f0; }
.strain-label { font-size:8pt; cursor:pointer; }    
#loading-message { position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background-color:rgba(255,255,255,0.8); padding:20px; border-radius:10px; z-index:1001; display:none; }
.container { height:calc(100vh - 50px); display:flex; flex-direction:column; }
.close-button { position:absolute; top:10px; right:10px; width:30px; height:30px; border:none; background:#434343; color:white; border-radius:50%; font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:background-color 0.3s; }
.close-button:hover { background-color:#666; }
.fullscreen-button-container { display:flex; flex-direction:column; gap:5px; position:absolute; top:70px; right:10px; z-index:997; }
.fullscreen-button-container button { width:100%; padding:3px 5px; border:2px solid #cccccc; border-radius:0; cursor:pointer; font-size:0.3em; font-family:'Poppins', Arial, sans-serif; transition:all 0.3s ease; color:#cccccc; background-color:white; }
.zoom-button-container { display:flex; width:100%; gap:5px; }
#zoomInButton, #zoomOutButton { flex:1; padding:0px 5px; font-size:16px; font-weight:bold; }
#zoomInButton { border-right:2px solid #cccccc; border-top-right-radius:0; border-bottom-right-radius:0; }
#zoomOutButton { border-left:2px solid #cccccc; border-top-left-radius:0; border-bottom-left-radius:0; }
.chart-container { flex-grow:1; width:100%; overflow:hidden; }
#lineageChart { width:100%; height:100%; }
.node { transition: transform 0.0s ease; }
.node use { z-index:1000; pointer-events:none; }    
.node text { font-size:16px; fill:black; text-anchor:start; dominant-baseline:middle; font-family:'Roboto', Arial, sans-serif; font-weight:700; }
.node text { z-index:999; }
.node text.product { font-size:10px; font-weight:normal; }
.node.clicked rect { stroke:#f0f; stroke-width:8px; }    
.node.dimmed rect { opacity:.05; }
.node.dimmed text { opacity:.05; }
.node.dimmed use { opacity:.05; }
.link.dimmed { opacity:.05; }
.node.highlighted rect { stroke:#f0f; stroke-width:3px; }
.node.highlighted-search .highlight-arrow { fill:red; }        
.link.highlighted { stroke:#f0f !important; stroke-width:3px; }
.pct-pill { fill:#000; stroke:#000; stroke-width:0px; }
.pct-pill-text { fill:#fff; font-size:9px; font-weight:700; pointer-events:none; }
</style>

</head>
<body>

<!-- Header -->
<div class="header-ribbon">
    <h1>
        WeedTree.fyi Strain Lineage Chart
        <span class="subhead">Work in progress, errors probable</span>
    </h1>
    <div class="header-buttons">
        <!-- Search -->
        <div class="search-container">
            <input type="text" id="strainSearch" placeholder="Locate strain">
            <div id="strainDropdown"></div>
        </div>
        <!-- About Button -->
        <button id="btn3" class="btn">About</button>
    </div>
</div>

<!-- Fullscreen & Zoom Controls -->
<div class="fullscreen-button-container">
    <button id="fullscreenToggle" class="btn">Toggle Full Screen</button>
    
    <div class="zoom-button-container">
        <button id="zoomInButton" class="btn">+</button>
        <button id="zoomOutButton" class="btn">-</button>
    </div>
    
    <button id="deselectButton" class="btn">De-select</button>
</div>

<!-- Chart Container -->
<div class="container">
    <div class="chart-container">
        <div id="lineageChart"></div>
    </div>
</div>

<!-- Popups -->
<div class="popup-overlay"></div>

<!-- Strain List Popup -->
<div id="popup1" class="popup">
    <div id="strainList" class="strain-list"></div>
</div>

<!-- Coming Soon Popup -->
<div id="popup2" class="popup">
    <h5>Record and rate your strains - coming soon</h5>
</div>

<!-- About / Welcome Popup -->
<div id="popup3" class="popup">
    <button class="close-button">Ã—</button>
    
    <h2>Welcome to Weedtree, the family tree of cannabis strains</h2>
    
    <p>I've always wondered how strain lineage correlated with the strains I personally prefer. Indica vs Sativa, Kush vs Afghani, Skunk vs Thai. I haven't been able to find much of a lineage chart anywhere online so decided to create one myself.</p>
    
    <p>I don't claim that the chart is completely accurate. It is based on what I could interpret from the multitude of, often contradictory, strain database sites internationally, and I've made some simplifications around phenotype/cultivar/clone/variant pedigree. Obviously, it is far from complete.</p>
    
    <p>
        Push F11 to toggle full screen.<br>
        Use the mouse or controls to zoom in and out.<br>
        Nodes are draggable within their column (press shift / long press on mobile).<br>
        Click on a strain to isolate its lineage.
    </p>
    
    <p>Isolation mode shows rough percentage of contribution based on lineage, but will be inaccurate as it does not account for the realities and nuances of selective breeding.</p>
    
    <p>Sorry it's a bit hard to use on mobile; best on a large screen. Strain search isn't working on mobile at the moment either.</p>
</div>

<!-- Loading Message -->
<div id="loading-message">Loading strain data, please wait...</div>

<!-- Center Line for Chart -->
<div id="centerLine"></div>

    
<svg id="nzIconTemplate" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" style="display: none;">
  <symbol id="nzIcon">
    <circle cx="14" cy="14" r="12.5" fill="white" stroke="black" stroke-width="3"/>
    <line x1="7" y1="9" x2="7" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="7" y1="9" x2="13" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="13" y1="9" x2="13" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="16" y1="9" x2="20.5" y2="9" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="16" y1="19" x2="21.5" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="21.5" y1="9" x2="16" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
  </symbol>
</svg>

<script>
let strainData = [];
let attributes = [];
let nodes = [];
let svg, g, zoom;
let focusedNode = null;
let lineWidth = 2;

// --- Shared node layout constants ---
const nodePillHeight = 30;
const nodeStrokeWidth = 3;
const nodeStrokeColor = '#000';
const nodeTextYOffset = 1;

// --- Error handling ---
const showError = (message) => {
    document.getElementById('loading-message').style.display = 'none';
    alert(message);
};

// --- Fetch and parse CSV data ---
fetch('https://docs.google.com/spreadsheets/d/e/2PACX-1vSoTjN6psMidKhKOaAxqcZQQ_ArKkUTuRgn65c3ncNqjdLASER0J-Z3WYxFNuhFX_gDVoyHyH1PcCZy/pub?output=csv&gid=1070299978')
    .then(response => {
        if (!response.ok) throw new Error("Network response was not ok");
        return response.text();
    })
    .then(csvText => {
        const rows = csvText.trim().split('\n').map(row => row.split(',').map(cell => cell.trim()));
        if (rows.length < 2) {
            showError("Not enough data in the spreadsheet.");
            return;
        }

        attributes = rows[0];
        strainData = rows.slice(1).map(row => {
            let obj = {};
            attributes.forEach((attr, index) => obj[attr] = row[index] || '');
            return obj;
        }).filter(obj => Object.values(obj).some(value => value !== ''));

        document.getElementById('loading-message').style.display = 'none';
        createLineageChart();
        setupStrainSearch();
    })
    .catch(error => {
        showError("Error fetching data: " + error.message);
        console.error("Fetch error:", error);
    });

// --- Strain list population ---
function populateStrainList() {
    const strainList = document.getElementById('strainList');
    strainList.innerHTML = '';

    const sortedStrains = nodes
        .filter(strain => !strain.name.toLowerCase().includes('unknown'))
        .sort((a, b) => a.name.localeCompare(b.name));

    sortedStrains.forEach(strain => {
        const strainItem = document.createElement('div');
        strainItem.className = 'strain-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `strain-${strain.id}`;
        checkbox.className = 'strain-checkbox';

        const label = document.createElement('label');
        label.htmlFor = `strain-${strain.id}`;
        label.className = 'strain-label';
        label.textContent = strain.name + (strain.product ? ` (${strain.product})` : '');

        strainItem.appendChild(checkbox);
        strainItem.appendChild(label);
        strainList.appendChild(strainItem);
    });
}

// --- Custom sorting functions ---
function customSortColumn2(a, b) {
    const dominanceOrder = {
        'indica dominant': 0,
        'ruderalis dominant': 1,
        'balanced hybrid': 2,
        'unknown': 3,
        'sativa dominant': 4
    };

    const indicaOrder = [
        'Afghan/Pakistan Indica Landraces',
        'Purple Afghan Indica Landraces',
        'Hindu Kush Landraces',
        'Nepalese Indica Landraces',
        'North American Indica Landraces'
    ];

    const sativaOrder = [
        'South India Sativa Landraces',
        'Burmese Sativa Landraces',
        'Cambodia Sativa Landraces',
        'Thai Sativa Landraces',
        'Chocolate Thai Sativa Landraces',
        'Purple Thai Sativa Landraces',
        'Indonesia Sativa Landraces',
        'North African Sativa Landraces',
        'East African Sativa landraces',
        'South African Sativa Landraces',
        'Jamaican Sativa Landraces',
        'California Sativa Landraces',
        'Mexico Sativa Landraces',
        'Panama Sativa Landraces',
        'Colombian Sativa Landraces',
        'Brazil Sativa Landraces',
        'Hawaiian Sativa Landraces'
    ];

    const aDom = a.dominance.toLowerCase();
    const bDom = b.dominance.toLowerCase();

    if (aDom !== bDom) return dominanceOrder[aDom] - dominanceOrder[bDom];

    if (aDom === 'indica dominant') {
        const aIndex = indicaOrder.indexOf(a.name);
        const bIndex = indicaOrder.indexOf(b.name);
        if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
        if (aIndex !== -1) return -1;
        if (bIndex !== -1) return 1;
    }

    if (aDom === 'sativa dominant') {
        const aIndex = sativaOrder.indexOf(a.name);
        const bIndex = sativaOrder.indexOf(b.name);
        if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
        if (aIndex !== -1) return -1;
        if (bIndex !== -1) return 1;
    }

    return a.name.localeCompare(b.name);
}

function customSortColumn3Plus(a, b) {
    const dominanceOrder = {
        'indica dominant': 0,
        'balanced hybrid': 1,
        'unknown': 2,
        'sativa dominant': 3
    };

    const aDom = a.dominance.toLowerCase();
    const bDom = b.dominance.toLowerCase();
    if (aDom !== bDom) return dominanceOrder[aDom] - dominanceOrder[bDom];
    return a.name.localeCompare(b.name);
}

// --- Barycentric sorting ---
function barycentricSort(genNodes, nodes, direction = 'parents') {
    return genNodes
        .map(n => {
            const refs = direction === 'parents'
                ? n.parents.map(pid => nodes.find(p => p.id === pid)).filter(Boolean)
                : nodes.filter(c => c.parents.includes(n.id));
            const avgY = refs.length ? d3.mean(refs, r => r.y) : n.y;
            return { node: n, avgY };
        })
        .sort((a, b) => (a.avgY ?? Infinity) - (b.avgY ?? Infinity))
        .map(d => d.node);
}

// --- Column positioning ---
function calculateColumn1Positions() {
    nodes.filter(n => n.generation === 0).forEach(node => {
        const children = nodes.filter(n => n.parents.includes(node.id));
        if (children.length) node.y = d3.mean(children, d => d.y);
    });
}

// --- Percentage formatting ---
function formatPercentage(p) {
    const capped = Math.min(p, 100);
    return capped < 5 ? '<5%' : `${capped.toFixed(0)}%`;
}

// --- Upward contribution calculation ---
function calculateUpwardChildTotals(startNode, nodes) {
    const contributions = new Map();

    function walk(node, amount) {
        contributions.set(node.id, (contributions.get(node.id) || 0) + amount);

        let parents = (node.parents || []).map(pid => nodes.find(n => n.id === pid)).filter(Boolean);
        if (node.variant) {
            const base = nodes.find(n => n.name === node.variant);
            if (base) parents.push(base);
        }

        if (!parents.length) return;

        const split = amount / parents.length;
        parents.forEach(parent => walk(parent, split));
    }

    walk(startNode, 100);
    return contributions;
}

// --- Downward contribution calculation ---
function calculateDownwardDescendantTotals(startNode, nodes) {
    const contributions = new Map();

    function walk(node, amount) {
        if (node.id !== startNode.id) {
            contributions.set(node.id, (contributions.get(node.id) || 0) + amount);
        }

        const children = nodes.filter(n =>
            (n.parents && n.parents.includes(node.id)) || n.variant === node.name
        );

        children.forEach(child => {
            let parentCount = (child.parents?.length || 0) + (child.variant ? 1 : 0);
            if (!parentCount) return;
            walk(child, amount / parentCount);
        });
    }

    walk(startNode, 100);
    return contributions;
}

const createLineageChart = () => {
    const chartContainer = document.querySelector('.chart-container');
    const width = chartContainer.clientWidth;
    const height = chartContainer.clientHeight;

    // Clear previous chart
    d3.select("#lineageChart").selectAll("*").remove();

    svg = d3.select("#lineageChart")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    g = svg.append("g");

    zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => g.attr("transform", event.transform));

    svg.call(zoom);

    // --- Nodes ---
    nodes = strainData.map(strain => ({
        id: strain.Strain,
        name: strain.Strain,
        displayName: strain.Strain,
        dominance: strain.Dominance,
        parents: [strain.Parent1, strain.Parent2, strain.Parent3, strain.Parent4].filter(p => p),
        generation: 0,
        special: strain.Special,
        product: strain.Product,
        variant: strain.Variant,
        alsoKnownAs: strain['Also Known As']
    }));

    const hasChildren = new Set(nodes.flatMap(n => n.parents));
    nodes = nodes.filter(n => hasChildren.has(n.name) || n.parents.length > 0 || n.special || n.variant);

    nodes.forEach(n => {
        if (n.name.toLowerCase().includes('unknown')) {
            n.displayName = n.name.replace(/\d+/g, '');
        }
    });

    nodes.sort((a, b) => a.product && !b.product ? 1 : !a.product && b.product ? -1 : 0);

    // --- Links ---
    const links = [];
    nodes.forEach(node => {
        if (node.variant) {
            const parentNode = nodes.find(n => n.name === node.variant);
            if (parentNode) links.push({ source: parentNode.id, target: node.id });
        } else {
            node.parents.forEach(parent => {
                if (parent && nodes.some(n => n.id === parent)) links.push({ source: parent, target: node.id });
            });
        }
    });

    // --- Generation assignment ---
    const assignGenerations = () => {
        let changed = true;
        while (changed) {
            changed = false;
            nodes.forEach(node => {
                if (node.name.toLowerCase().includes('unknown lineages') && node.generation !== 2) {
                    node.generation = 2; changed = true;
                } else if (node.special?.toLowerCase() === 'origin' && node.generation !== 0) {
                    node.generation = 0; changed = true;
                } else if (node.special?.toLowerCase() === 'landrace' && node.generation !== 1) {
                    node.generation = 1; changed = true;
                } else if (node.variant) {
                    const parentNode = nodes.find(n => n.name === node.variant);
                    if (parentNode && node.generation !== parentNode.generation) { node.generation = parentNode.generation; changed = true; }
                } else if (node.name.toLowerCase().includes('unknown')) {
                    if (node.generation < 2) { node.generation = 2; changed = true; }
                } else {
                    const parentGens = node.parents.map(p => nodes.find(n => n.id === p)?.generation).filter(g => g !== undefined);
                    if (parentGens.length > 0) {
                        const maxParentGen = Math.max(...parentGens);
                        if (node.generation !== maxParentGen + 1) { node.generation = maxParentGen + 1; changed = true; }
                    }
                }
            });
        }

        let specialCaseChanged = true;
        while (specialCaseChanged) {
            specialCaseChanged = false;
            nodes.forEach(node => {
                if (!node.name.toLowerCase().includes('unknown lineages') &&
                    (node.name.toLowerCase().includes('unknown') ||
                    (node.parents.length && node.parents.every(p => nodes.find(n => n.id === p)?.name.toLowerCase().includes('unknown'))))) {
                        const children = nodes.filter(n => n.parents.includes(node.id));
                        if (children.length > 0) {
                            const minChildGen = Math.min(...children.map(c => c.generation));
                            const newGen = Math.max(2, minChildGen - 1);
                            if (node.generation !== newGen) { node.generation = newGen; specialCaseChanged = true; }
                        }
                    }
            });
        }
    };
    assignGenerations();

    // --- Layout ---
    const maxWidth = Math.max(...nodes.map(d => d.displayName.length * 7));
    const standardPillWidth = Math.max(maxWidth, 150);
    const pillHeight = 30;
    const maxGeneration = Math.max(...nodes.map(n => n.generation));
    const columnWidth = Math.max(width / (maxGeneration + 1), standardPillWidth * 1.6);

    const column2Nodes = nodes.filter(n => n.generation === 1 && !n.variant).sort(customSortColumn2);

    for (let gen = 0; gen <= maxGeneration + 1; gen++) {
        let genNodes = nodes.filter(n => n.generation === gen || (gen === 1 && n.special?.toLowerCase() === 'landrace'));
        if (gen === 1) genNodes = column2Nodes.concat(genNodes.filter(n => !column2Nodes.includes(n)));
        else if (gen >= 2) genNodes.sort(customSortColumn3Plus);

        let yOffset = 0;
        const totalHeight = genNodes.filter(n => !n.variant).length * (pillHeight + 10) + genNodes.filter(n => n.variant).length * (pillHeight + 2);
        const startY = (height - totalHeight) / 2;

        genNodes.forEach(node => {
            node.x = gen * columnWidth;
            if (!node.variant) {
                if (gen !== 0 || node.y === undefined) node.y = startY + yOffset;
                yOffset += pillHeight + 16;

                const variants = nodes.filter(n => n.variant === node.name).sort((a, b) => a.name.localeCompare(b.name));
                variants.forEach((v, idx) => v.y = node.y + (idx + 1) * (pillHeight + 2));
                yOffset += variants.length * (pillHeight + 2);
            }
        });

        if (gen >= 2) {
            genNodes = barycentricSort(genNodes, nodes, 'parents');
            yOffset = 0;
            genNodes.forEach(node => {
                if (!node.variant) {
                    node.y = startY + yOffset;
                    yOffset += pillHeight + 16;
                    const variants = nodes.filter(n => n.variant === node.name).sort((a,b)=>a.name.localeCompare(b.name));
                    variants.forEach((v, idx)=>v.y = node.y + (idx+1)*(pillHeight+2));
                    yOffset += variants.length*(pillHeight+2);
                }
            });
        }
    }

    calculateColumn1Positions();

    // --- Links ---
    const link = g.append("g")
        .selectAll("path")
        .data(links)
        .join("path")
        .attr("class", "link")
        .attr("stroke", d => darkenColor(getColorByDominance(nodes.find(n => n.id === d.source).dominance), 2))
        .attr("stroke-opacity", 1)
        .attr("stroke-width", lineWidth + 1)
        .attr("fill", "none")
        .attr("d", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            const sW = sourceNode.variant ? standardPillWidth*0.85 : standardPillWidth;
            const tW = targetNode.variant ? standardPillWidth*0.85 : standardPillWidth;
            const midX = (sourceNode.x + sW/2 + targetNode.x - tW/2)/2;
            return `M${sourceNode.x+sW/2},${sourceNode.y} C${midX},${sourceNode.y} ${midX},${targetNode.y} ${targetNode.x-tW/2},${targetNode.y}`;
        });

    // --- Nodes ---
    let dragging = false;

    const node = g.append("g")
        .selectAll("g")
        .data(nodes)
        .join("g")
        .attr("class","node")
        .attr("transform", d=>`translate(${d.x},${d.y})`)
        .each(d=>{if(d.product)d3.select(this).raise();})
        .on("click", highlightLineage)
        .on("mouseover", function(event,d){
            if(dragging)return;
            highlightHoverLineage(event,d);
            d3.select(this).raise().transition().attr("transform",`translate(${d.x},${d.y}) scale(1.7,1.7)`);
        })
        .on("mouseout", function(event,d){
            if(dragging)return;
            removeHighlightHoverLineage();
            d3.select(this).transition().attr("transform",`translate(${d.x},${d.y}) scale(1)`);
            g.selectAll(".node").each(d=>{if(d.product)d3.select(this).raise();});
        });

    // --- Drag ---
    node.call(d3.drag()
        .on("start", function(event,d){
            if(event.sourceEvent.type.startsWith("touch")){
                d.longPressTimer=setTimeout(()=>startDrag(event,d,this),400);
            } else {
                if(!event.sourceEvent.shiftKey) return;
                startDrag(event,d,this);
            }
        })
        .on("drag", function(event,d){
            if(!d.dragging) return;
            dragNode(event,d,this);
        })
        .on("end", function(event,d){
            if(d.longPressTimer){ clearTimeout(d.longPressTimer); d.longPressTimer=null; }
            if(!d.dragging) return;
            d.dragging=false;
            dragging=false;
        })
    );

    // --- Append node rects and text ---
    node.append("rect")
        .attr("rx",pillHeight/2).attr("ry",pillHeight/2)
        .attr("width",d=>d.variant?standardPillWidth*0.85:standardPillWidth)
        .attr("height",pillHeight)
        .attr("fill",d=>{
            if(d.variant){
                const parent = nodes.find(n=>n.name===d.variant);
                if(parent) return blendToWhite(getColorByDominance(parent.dominance),0.5);
            }
            return getColorByDominance(d.dominance);
        })
        .attr("x",d=>d.variant?-(standardPillWidth*0.85)/2:-standardPillWidth/2)
        .attr("y",-pillHeight/2)
        .attr("stroke",d=>d.product?"black":getColorByDominance(d.dominance))
        .attr("stroke-width",3);

    node.append("text")
        .attr("class","strain-name")
        .text(d=>d.displayName)
        .attr("x",d=>d.variant?-(standardPillWidth*0.85)/2+12:-standardPillWidth/2+12)
        .attr("y",1)
        .attr("dominant-baseline","middle")
        .attr("fill","black")
        .style("font-size","15px")
        .style("font-family","'Roboto', Arial, sans-serif")
        .style("font-weight","bold")
        .each(function(d){
            const textWidth=this.getComputedTextLength();
            const nodeWidth=d.variant?standardPillWidth*0.85:standardPillWidth;
            const available=nodeWidth-24;
            if(textWidth>available)d3.select(this).style("font-family","'Roboto Condensed', Arial, sans-serif");
        });

    node.append("text")
        .filter(d=>d.product)
        .text(d=>d.product)
        .attr("class","product")
        .attr("y",1.6)
        .attr("dominant-baseline","middle")
        .attr("fill","black")
        .style("font-size","10px")
        .style("font-family","'Roboto', Arial, sans-serif")
        .style("font-weight","normal")
        .each(function(d){
            const strainText=this.parentNode.querySelector('.strain-name');
            const nodeWidth=d.variant?standardPillWidth*0.85:standardPillWidth;
            const rem=nodeWidth-strainText.getComputedTextLength()-40;
            if(this.getComputedTextLength()>rem){
                d3.select(this).style("font-family","'Roboto Condensed', Arial, sans-serif");
                d3.select(strainText).style("font-family","'Roboto Condensed', Arial, sans-serif");
            }
        });

    node.filter(d=>d.product).append("use")
        .attr("xhref","#nzIcon")
        .attr("width",30).attr("height",30)
        .attr("x",d=> (d.variant?standardPillWidth*0.85:standardPillWidth)/2 - 20)
        .attr("y",-14);

    // --- Zoom setup ---
    const initialTransform = calculateInitialTransform();
    svg.call(zoom.transform, initialTransform);

    // --- Populate list ---
    populateStrainList();

    // --- Auto-focus URL strain ---
    (function autoFocusFromURL(){
        const urlParams = new URLSearchParams(window.location.search);
        let focusStrain = urlParams.get('focus');
        if(!focusStrain) return;
        focusStrain = focusStrain.replace(/_/g,' ').replace(/\s+/g,' ').trim().toLowerCase();
        requestAnimationFrame(()=>{
            const targetNode=nodes.find(n=>n.name.replace(/\s+/g,' ').trim().toLowerCase()===focusStrain);
            if(!targetNode) return;
            console.log("Focusing on strain:", targetNode.name);
            highlightLineage(null,targetNode);
        });
    })();
};






//////////////////
    
const getColorByDominance = (dominance) => {
    switch(dominance.toLowerCase()) {
        case 'sativa dominant': return '#ffea8a';
        case 'indica dominant': return '#9be7f5';
        case 'ruderalis dominant': return '#d9d2e9';    
        case 'balanced hybrid': return '#bee8a6';
        case 'unknown': return '#d1e6cb';
        default: return '#EAEAEA';
    }
};

const darkenColor = (color, amount) => d3.color(color).darker(amount / 10).toString();
const blendToWhite = (color, amount) => {
    const baseColor = d3.color(color);
    const whiteColor = d3.color("#ffffff");
    // Interpolating the color towards white based on the amount (0 to 1)
    const interpolatedColor = d3.interpolateRgb(baseColor, whiteColor)(amount);
    return interpolatedColor;
};

function setupStrainSearch() {
    const searchInput = document.getElementById('strainSearch');
    const dropdown = document.getElementById('strainDropdown');
    let highlightedNode = null;

    searchInput.addEventListener('input', function() {
        const searchText = this.value.toLowerCase();
        if (searchText.length === 0) {
            dropdown.style.display = 'none';
            return;
        }

        const matchingStrains = nodes.filter(node => 
            !node.name.toLowerCase().includes('unknown') && (
                node.name.toLowerCase().includes(searchText) ||
                (node.product && node.product.toLowerCase().includes(searchText)) ||
                (node.alsoKnownAs && node.alsoKnownAs.toLowerCase().includes(searchText))
            )
        );

        dropdown.innerHTML = '';
        matchingStrains.sort((a, b) => a.name.localeCompare(b.name)).forEach(strain => {
            const div = document.createElement('div');
            div.innerHTML = strain.name + 
                            (strain.product ? `<br>(${strain.product})` : '') + 
                            (strain.alsoKnownAs ? ` [${strain.alsoKnownAs}]` : '');
            div.addEventListener('click', () => {
                highlightStrain(strain);
                dropdown.style.display = 'none';
                searchInput.value = '';
            });
            dropdown.appendChild(div);
        });

        dropdown.style.display = matchingStrains.length > 0 ? 'block' : 'none';
    });

    document.addEventListener('click', function(event) {
        if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
            dropdown.style.display = 'none';
        }
    });

    function highlightStrain(strain) {
        if (highlightedNode) {
            d3.select(highlightedNode).select('.highlight-arrow').remove();
            highlightedNode = null;
        }

        const node = g.selectAll('.node').filter(d => d.id === strain.id);
        const arrow = node.append('path')
            .attr('d', 'M-70,-6 L-39,0 L-70,6 Z')
            .attr('class', 'highlight-arrow')
            .attr('fill', 'red')
            .attr('transform', 'translate(0,0) scale(3)');

        arrow.on('mouseover', function() {
            d3.select(this).remove();
            highlightedNode = null;
        });

        arrow.on('click', function(event) {
            event.stopPropagation();
        });

        highlightedNode = node.node();

        zoomToNode(strain);
    }

    function zoomToNode(strain) {
        const transform = d3.zoomTransform(svg.node());
        const scale = 2;
        const x = -strain.x * scale + svg.attr('width') / 2;
        const y = -strain.y * scale + svg.attr('height') / 2;

        svg.transition()
            .duration(750)
            .call(d3.zoom().transform, d3.zoomIdentity.translate(x, y).scale(scale));
    }
}
// --- FIX: remove undefined fetchData() call and ensure About popup opens ---
window.addEventListener('load', function() {
    // Add event listeners for About popup
    const aboutBtn = document.getElementById('btn3');
    const popup3 = document.getElementById('popup3');
    const overlay = document.querySelector('.popup-overlay');
    if (aboutBtn && popup3 && overlay) {
        aboutBtn.addEventListener('click', () => {
            popup3.style.display = 'block';
            overlay.style.display = 'block';
        });
        // Show About popup on initial load
        popup3.style.display = 'block';
        overlay.style.display = 'block';
    }
});

document.querySelectorAll('.close-button').forEach(button => {
    button.addEventListener('click', function() {
        const popup = this.closest('.popup');
        popup.style.display = 'none';
        document.querySelector('.popup-overlay').style.display = 'none';
    });
});

document.getElementById('fullscreenToggle').addEventListener('click', toggleFullScreen);
document.getElementById('zoomInButton').addEventListener('click', () => {
    const currentTransform = d3.zoomTransform(svg.node());
    const newScale = currentTransform.k * 1.05; // Increase zoom by 20%
    
    if (newScale <= zoom.scaleExtent()[1]) { // Check if within max zoom limit
        svg.transition()
            .duration(250)
            .call(zoom.transform, 
                d3.zoomIdentity
                    .translate(currentTransform.x, currentTransform.y)
                    .scale(newScale)
            );
    }
});

document.getElementById('zoomOutButton').addEventListener('click', () => {
    const currentTransform = d3.zoomTransform(svg.node());
    const newScale = currentTransform.k / 1.05; // Decrease zoom by 20%
    
    if (newScale >= zoom.scaleExtent()[0]) { // Check if within min zoom limit
        svg.transition()
            .duration(250)
            .call(zoom.transform, 
                d3.zoomIdentity
                    .translate(currentTransform.x, currentTransform.y)
                    .scale(newScale)
            );
    }
});

document.getElementById('deselectButton').addEventListener('click', () => {
    if (focusedNode) {

        g.selectAll('.pct-pill').remove();
        g.selectAll('.pct-pill-text').remove();

        g.selectAll(".node")
            .classed("dimmed", false)
            .classed("clicked", false);

        g.selectAll("path.link")
            .classed("dimmed", false)
            .attr("stroke-width", lineWidth + 1);

        focusedNode = null;
        resetZoom();
    }
});


function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

window.addEventListener('resize', function() {
    createLineageChart();
    adjustFullscreenButtonPosition();
    adjustButtonFontSize();
});

function adjustFullscreenButtonPosition() {
    const ribbon = document.querySelector('.header-ribbon');
    const fullscreenButton = document.querySelector('.fullscreen-button-container');
    if (ribbon && fullscreenButton) {
        const ribbonHeight = ribbon.offsetHeight;
        fullscreenButton.style.top = (ribbonHeight + 10) + 'px';
    }
}

function adjustButtonFontSize() {
    const buttons = document.querySelectorAll('.btn:not(#btn3)'); // Exclude the About button
    const headerButtons = document.querySelector('.header-buttons');
    
    // Guard clause - if either buttons or headerButtons don't exist, return early
    if (!buttons.length || !headerButtons) {
        return;
    }
    
    const availableWidth = headerButtons.offsetWidth;
    let totalButtonWidth = 0;

    // Add the fixed width of the About button
    const aboutButton = document.getElementById('btn3');
    const aboutButtonWidth = aboutButton ? aboutButton.offsetWidth : 0;
    
    buttons.forEach(button => {
        if (button) {
            button.style.fontSize = '0.9em'; // Reset to original size
            totalButtonWidth += button.offsetWidth;
        }
    });

    // Account for the About button's width in the available space
    const adjustableWidth = availableWidth - aboutButtonWidth;

    if (totalButtonWidth > adjustableWidth) {
        const scaleFactor = adjustableWidth / totalButtonWidth;
        buttons.forEach(button => {
            if (button) {
                const newSize = parseFloat(getComputedStyle(button).fontSize) * scaleFactor;
                button.style.fontSize = `${newSize}px`;
            }
        });
    }
}

window.addEventListener('load', adjustButtonFontSize);

document.querySelector('.popup-overlay').addEventListener('click', function() {
    document.querySelectorAll('.popup').forEach(popup => popup.style.display = 'none');
    this.style.display = 'none';
});

document.querySelectorAll('.popup').forEach(popup => 
    popup.addEventListener('click', event => event.stopPropagation())
);



    
</script>
</body>
</html>




