<html><head><base href="https://www.weedtree.com/strain_lineage_chart">
<title>WeedTree Strain Lineage Chart</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%0A%3C!--%20Generator%3A%20Adobe%20Illustrator%2014.0.0%2C%20SVG%20Export%20Plug-In%20%20--%3E%0A%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%20%5B%0A%09%3C!ENTITY%20ns_flows%20%22http%3A%2F%2Fns.adobe.com%2FFlows%2F1.0%2F%22%3E%0A%5D%3E%0A%3Csvg%20version%3D%221.1%22%0A%09%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20xmlns%3Aa%3D%22http%3A%2F%2Fns.adobe.com%2FAdobeSVGViewerExtensions%2F3.0%2F%22%0A%09%20x%3D%220px%22%20y%3D%220px%22%20width%3D%22850px%22%20height%3D%22850px%22%20viewBox%3D%22-4.373%20-62.583%20850%20850%22%20enable-background%3D%22new%20-4.373%20-62.583%20850%20850%22%0A%09%20xml%3Aspace%3D%22preserve%22%3E%0A%3Cdefs%3E%0A%3C%2Fdefs%3E%0A%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%2391C83E%22%20d%3D%22M39.597%2C362.632L39.597%2C362.632%0A%09c0-178.392%2C170.697-323.035%2C381.267-323.035c210.492%2C0%2C381.188%2C144.644%2C381.188%2C323.035c0%2C178.388-170.695%2C322.998-381.188%2C322.998%0A%09C210.294%2C685.63%2C39.597%2C541.021%2C39.597%2C362.632z%22%2F%3E%0A%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%236FAC43%22%20d%3D%22M503.249%2C266.012c0-18.56%2C17.775-33.65%2C39.697-33.65%0A%09c21.934%2C0%2C39.739%2C15.09%2C39.739%2C33.65c0%2C18.598-17.806%2C33.653-39.739%2C33.653C521.024%2C299.665%2C503.249%2C284.61%2C503.249%2C266.012%0A%09%20M259.004%2C266.012c0-18.56%2C17.763-33.65%2C39.697-33.65c21.927%2C0%2C39.731%2C15.09%2C39.731%2C33.65c0%2C18.598-17.805%2C33.653-39.731%2C33.653%0A%09C276.767%2C299.665%2C259.004%2C284.61%2C259.004%2C266.012%22%2F%3E%0A%3Cpath%20opacity%3D%220%22%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%23010101%22%20d%3D%22M214.215%2C503.485%0A%09c137.758%2C80.19%2C275.325%2C80.19%2C412.744%2C0%22%2F%3E%0A%3Cpath%20opacity%3D%220%22%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%23010101%22%20d%3D%22M39.597%2C362.632L39.597%2C362.632%0A%09c0-178.392%2C170.697-323.035%2C381.267-323.035c210.492%2C0%2C381.188%2C144.644%2C381.188%2C323.035c0%2C178.388-170.695%2C322.998-381.188%2C322.998%0A%09C210.294%2C685.63%2C39.597%2C541.021%2C39.597%2C362.632z%22%2F%3E%0A%3Cpath%20fill%3D%22none%22%20stroke%3D%22%23444444%22%20stroke-width%3D%2279.1948%22%20stroke-linejoin%3D%22round%22%20stroke-miterlimit%3D%228%22%20d%3D%22M503.249%2C266.012%0A%09c0-18.56%2C17.775-33.65%2C39.697-33.65c21.934%2C0%2C39.739%2C15.09%2C39.739%2C33.65c0%2C18.598-17.806%2C33.653-39.739%2C33.653%0A%09C521.024%2C299.665%2C503.249%2C284.61%2C503.249%2C266.012%20M259.004%2C266.012c0-18.56%2C17.763-33.65%2C39.697-33.65%0A%09c21.927%2C0%2C39.731%2C15.09%2C39.731%2C33.65c0%2C18.598-17.805%2C33.653-39.731%2C33.653C276.767%2C299.665%2C259.004%2C284.61%2C259.004%2C266.012%22%2F%3E%0A%3Cpath%20fill%3D%22none%22%20stroke%3D%22%23444444%22%20stroke-width%3D%2279.1948%22%20stroke-linejoin%3D%22round%22%20stroke-miterlimit%3D%228%22%20d%3D%22M214.215%2C503.485%0A%09c137.758%2C80.19%2C275.325%2C80.19%2C412.744%2C0%22%2F%3E%0A%3Cpath%20fill%3D%22none%22%20stroke%3D%22%23444444%22%20stroke-width%3D%2279.1948%22%20stroke-linejoin%3D%22round%22%20stroke-miterlimit%3D%228%22%20d%3D%22M39.597%2C362.632%0A%09L39.597%2C362.632c0-178.392%2C170.697-323.035%2C381.267-323.035c210.492%2C0%2C381.188%2C144.644%2C381.188%2C323.035%0A%09c0%2C178.388-170.695%2C322.998-381.188%2C322.998C210.294%2C685.63%2C39.597%2C541.021%2C39.597%2C362.632z%22%2F%3E%0A%3C%2Fsvg%3E">
<style>
body,html{font-family:'Poppins',Arial,sans-serif;background-color:#fff;margin:0;padding:0;font-size:14px;height:100%;overflow:hidden}.header-ribbon{background-color:#434343;color:#fff;padding:10px;display:flex;justify-content:space-between;align-items:center}.header-ribbon h1{margin:0;font-size:1.8em;color:#fff;margin-left:6px}.subhead{font-size:.4em;font-weight:400;margin-left:3px}.container{height:calc(100vh - 50px);display:flex;flex-direction:column}.chart-container{flex-grow:1;width:100%;overflow:hidden}#lineageChart{width:100%;height:100%}.header-buttons{display:flex;gap:10px;align-items:center}.btn{background-color:transparent;color:#fff;padding:5px 15px;border:2px solid #fff;border-radius:18px;cursor:pointer;font-size:.9em;font-family:'Poppins',Arial,sans-serif;transition:all .3s ease}.btn:hover{background-color:rgba(255,255,255,.1)}.node text{font-size:10px;fill:#434343;text-anchor:start;dominant-baseline:middle;font-family:'Poppins',Arial,sans-serif;font-weight:700}.node text.product{font-size:12px;font-weight:400}.node.dimmed rect{opacity:.15}.node.dimmed text{opacity:.15}.link.dimmed{opacity:.15}.node.highlighted rect{stroke:#f0f;stroke-width:3px}.link.highlighted{stroke:#f0f!important;stroke-width:3px}.node.clicked rect{stroke:#f0f;stroke-width:3px}.popup{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:94%;height:90%;background-color:#fff;border:2px solid #434343;border-radius:15px;z-index:1000;display:none;overflow:auto;padding:20px}.popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);z-index:999;display:none}#loading-message{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(255,255,255,0.8);padding:20px;border-radius:10px;z-index:1001;display:none}
#strainSearch{background-color:transparent;color:#fff;padding:5px 15px;border:2px solid #fff;border-radius:18px;font-size:.9em;font-family:'Poppins',Arial,sans-serif;transition:all .3s ease;width:180px}#strainSearch::placeholder{color:rgba(255,255,255,0.7)}#strainSearch:focus{outline:none;background-color:rgba(255,255,255,0.1)}#strainDropdown{position:absolute;background-color:#fff;border:1px solid #ccc;max-height:400px;overflow-y:auto;display:none;z-index:1000;width:210px;box-shadow:1 4px 8px rgba(0,0,0,0.1);border-radius:0 0 4px 4px}#strainDropdown div{padding:5px 10px;cursor:pointer;transition:background-color 0.2s;color:#434343;font-size:8pt;line-height:1.2}#strainDropdown div:hover{background-color:#f0f0f0}.search-container{position:relative}.node.highlighted-search .highlight-arrow{fill:red}
</style>
<script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
<div class="header-ribbon">
    <h1>WeedTree Strain Lineage Chart <span class="subhead">Work in progress, errors probable</span></h1>
    <div class="header-buttons">
        <div class="search-container">
            <input type="text" id="strainSearch" placeholder="Locate strain">
            <div id="strainDropdown"></div>
        </div>
        <button id="btn1" class="btn">Filter Strains</button>
        <button id="btn2" class="btn">My Strains</button>
        <button id="btn3" class="btn">About</button>
    </div>
</div>
<div class="container">
    <div class="chart-container">
        <div id="lineageChart"></div>
    </div>
</div>
<div class="popup-overlay"></div>
<div id="popup1" class="popup"><h2>Filter the chart - coming soon</h2></div>
<div id="popup2" class="popup"><h2>Record and rate your strains - coming soon</h2></div>
<div id="popup3" class="popup"><h2>coming soon</h2></div>
<div id="loading-message">Loading data, please wait...</div>
<script>
let strainData = [], attributes = [], nodes = [], svg, g;
const showError = (message) => {
    document.getElementById('loading-message').style.display = 'none';
    alert(message);
};
function fetchData() {
    document.getElementById('loading-message').style.display = 'block';
    fetch('https://docs.google.com/spreadsheets/d/e/2PACX-1vSoTjN6psMidKhKOaAxqcZQQ_ArKkUTuRgn65c3ncNqjdLASER0J-Z3WYxFNuhFX_gDVoyHyH1PcCZy/pubhtml?gid=1070299978&single=true')
        .then(response => response.text())
        .then(html => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const table = doc.querySelector('table');
            if (!table) {
                showError("No table found in the spreadsheet.");
                return;
            }
            const rows = Array.from(table.querySelectorAll('tr')).filter(row => row.textContent.trim() !== '');
            if (rows.length < 2) {
                showError("Not enough data in the spreadsheet.");
                return;
            }            
            const headerRowIndex = rows.findIndex(row => row.querySelector('td').textContent.trim() === 'Strain');
            if (headerRowIndex === -1) {
                showError("Could not find a row starting with 'Strain'.");
                return;
            }            
            attributes = Array.from(rows[headerRowIndex].querySelectorAll('td')).map(td => td.textContent.trim());
            strainData = rows.slice(headerRowIndex + 1).map(row => {
                let obj = {};
                Array.from(row.querySelectorAll('td')).forEach((td, index) => {
                    obj[attributes[index]] = td.textContent.trim();
                });
                return obj;
            }).filter(obj => Object.values(obj).some(value => value !== ''));
            document.getElementById('loading-message').style.display = 'none';
            createLineageChart();
            setupStrainSearch();
        })
        .catch(error => {
            showError("Error fetching data: " + error.message);
        });
}

const createLineageChart = () => {
    const chartContainer = document.querySelector('.chart-container');
    const width = chartContainer.clientWidth, height = chartContainer.clientHeight;
    d3.select("#lineageChart").selectAll("*").remove();
    svg = d3.select("#lineageChart").append("svg").attr("width", width).attr("height", height);
    g = svg.append("g");
    const zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => g.attr("transform", event.transform));
    svg.call(zoom);
    nodes = strainData.map(strain => ({
        id: strain.Strain,
        name: strain.Strain,
        displayName: strain.Strain,
        dominance: strain.Dominance,
        parents: [strain.Parent1, strain.Parent2, strain.Parent3, strain.Parent4].filter(p => p),
        generation: 0,
        special: strain.Special,
        product: strain.Product,
        variant: strain.Variant,
        alsoKnownAs: strain['Also Known As']
    }));
    const links = [];
    nodes.forEach(node => {
        if (node.variant) {
            const parentNode = nodes.find(n => n.name === node.variant);
            if (parentNode) links.push({ source: parentNode.id, target: node.id });
        } else {
            node.parents.forEach(parent => {
                if (parent && nodes.some(n => n.id === parent)) links.push({ source: parent, target: node.id });
            });
        }
    });
    const assignGenerations = () => {
        let changed = true;
        while (changed) {
            changed = false;
            nodes.forEach(node => {
                if (node.special && node.special.toLowerCase() === 'origin') {
                    if (node.generation !== 0) {
                        node.generation = 0;
                        changed = true;
                    }
                } else if (node.special && node.special.toLowerCase() === 'landrace') {
                    if (node.generation !== 1) {
                        node.generation = 1;
                        changed = true;
                    }
                } else if (node.variant) {
                    const parentNode = nodes.find(n => n.name === node.variant);
                    if (parentNode && node.generation !== parentNode.generation) {
                        node.generation = parentNode.generation;
                        changed = true;
                    }
                } else {
                    const parentGens = node.parents.map(parentId => {
                        const parent = nodes.find(n => n.id === parentId);
                        return parent ? parent.generation : -1;
                    }).filter(gen => gen !== -1);
                    if (parentGens.length > 0) {
                        const maxParentGen = Math.max(...parentGens);
                        if (node.generation !== maxParentGen + 1) {
                            node.generation = maxParentGen + 1;
                            changed = true;
                        }
                    }
                }
            });
        }
    };
    assignGenerations();
    const maxWidth = Math.max(...nodes.map(d => d.displayName.length * 7));
    const standardPillWidth = Math.max(maxWidth, 150);
    const pillHeight = 30, lineWidth = 2;
    const maxGeneration = Math.max(...nodes.map(n => n.generation));
    const columnWidth = Math.max(width / (maxGeneration + 1), standardPillWidth * 1.8);

    nodes.forEach(node => {
        if (node.special && node.special.toLowerCase() === 'origin') {
            node.x = columnWidth / 2;
        } else if (node.special && node.special.toLowerCase() === 'landrace') {
            node.x = columnWidth * 1.5;
        } else {
            node.x = (node.generation + 0) * columnWidth + columnWidth / 2;
        }
    });

    for (let gen = 0; gen <= maxGeneration + 1; gen++) {
        let genNodes = nodes.filter(n => 
            (n.generation === gen) || 
            (gen === 1 && n.special && n.special.toLowerCase() === 'landrace')
        );
        let yOffset = 0;
        genNodes.forEach((node, index) => {
            node.y = yOffset;
            yOffset += pillHeight + 10;
        });
    }

    const link = g.append("g")
        .selectAll("line")
        .data(links)
        .join("line")
        .attr("class", "link")
        .attr("stroke", d => darkenColor(getColorByDominance(nodes.find(n => n.id === d.source).dominance), 0))
        .attr("stroke-opacity", 1)
        .attr("stroke-width", lineWidth)
        .attr("x1", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const pillWidth = sourceNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
            return sourceNode.x + pillWidth / 2;
        })
        .attr("y1", d => nodes.find(n => n.id === d.source).y)
        .attr("x2", d => {
            const targetNode = nodes.find(n => n.id === d.target);
            const pillWidth = targetNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
            return targetNode.x - pillWidth / 2;
        })
        .attr("y2", d => nodes.find(n => n.id === d.target).y);
    const node = g.append("g")
        .selectAll("g")
        .data(nodes)
        .join("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .on("click", highlightLineage)
        .on("mouseover", highlightHoverLineage)
        .on("mouseout", removeHighlightHoverLineage);
    node.append("rect")
        .attr("rx", pillHeight / 2)
        .attr("ry", pillHeight / 2)
        .attr("width", d => d.variant ? standardPillWidth * 0.85 : standardPillWidth)
        .attr("height", pillHeight)
        .attr("fill", d => {
            if (d.variant) {
                switch(d.dominance.toLowerCase()) {
                    case 'indica dominant': return '#eff5f5';
                    case 'sativa dominant': return '#faf8e1';
                    case 'balanced hybrid': return '#f3f6e8';
                    case 'unknown': return '#f3f6e8';
                    default: return 'gray';
                }
            } else {
                return getColorByDominance(d.dominance);
            }
        })
        .attr("x", d => d.variant ? -(standardPillWidth * 0.85) / 2 : -standardPillWidth / 2)
        .attr("y", -pillHeight / 2)
        .attr("stroke", d => d.product ? "black" : getColorByDominance(d.dominance))
        .attr("stroke-width", 2);
    node.append("text")
        .attr("class", "strain-name")
        .text(d => d.displayName)
        .attr("x", d => d.variant ? -(standardPillWidth * 0.85) / 2 + 10 : -standardPillWidth / 2 + 10)
        .attr("y", 0)
        .attr("dominant-baseline", "middle")
        .attr("fill", "black")
        .style("font-size", "12px")
        .style("font-family", "'Poppins', Arial, sans-serif")
        .style("font-weight", "bold");
    node.append("text")
        .filter(d => d.product)
        .text(d => d.product)
        .attr("class", "product")
        .attr("x", function(d) {
            const strainNameWidth = this.parentNode.querySelector('.strain-name').getComputedTextLength();
            return (d.variant ? -(standardPillWidth * 0.85) / 2 : -standardPillWidth / 2) + 3 + strainNameWidth + 10;
        })
        .attr("y", 0)
        .attr("dominant-baseline", "middle")
        .attr("fill", "black")
        .style("font-size", "10px")
        .style("font-family", "'Poppins', Arial, sans-serif")
        .style("font-weight", "normal");
    let focusedNode = null;
    function highlightLineage(event, d) {
        if (focusedNode === d) {
            node.classed("dimmed", false);
            node.classed("clicked", false);
            link.classed("dimmed", false);
            focusedNode = null;
            resetZoom();
        } else {
            const lineage = new Set();
            const getAncestors = (node) => {
                lineage.add(node.id);
                if (node.variant) {
                    const parentNode = nodes.find(n => n.name === node.variant);
                    if (parentNode) {
                        lineage.add(parentNode.id);
                        getAncestors(parentNode);
                    }
                } else {
                    node.parents.forEach(parentId => {
                        const parent = nodes.find(n => n.id === parentId);
                        if (parent) {
                            lineage.add(parentId);
                            getAncestors(parent);
                        }
                    });
                }
            };
            const getDescendants = (nodeId) => {
                lineage.add(nodeId);
                const children = nodes.filter(n => n.parents.includes(nodeId) || (n.variant === nodes.find(node => node.id === nodeId).name));
                children.forEach(child => {
                    lineage.add(child.id);
                    getDescendants(child.id);
                });
            };
            getAncestors(d);
            getDescendants(d.id);
            node.classed("dimmed", n => !lineage.has(n.id));
            node.classed("clicked", n => n.id === d.id);
            link.classed("dimmed", l => !lineage.has(l.source) || !lineage.has(l.target));
            focusedNode = d;
            zoomToLineage(lineage);
        }
        // Remove highlight arrow when node is clicked
        d3.select(this).select('.highlight-arrow').remove();
    }
    function highlightHoverLineage(event, d) {
        const lineage = new Set();
        const getAncestors = (node) => {
            lineage.add(node.id);
            if (node.variant) {
                const parentNode = nodes.find(n => n.name === node.variant);
                if (parentNode) {
                    lineage.add(parentNode.id);
                    getAncestors(parentNode);
                }
            } else {
                node.parents.forEach(parentId => {
                    const parent = nodes.find(n => n.id === parentId);
                    if (parent) {
                        lineage.add(parentId);
                        getAncestors(parent);
                    }
                });
            }
        };
        const getDescendants = (nodeId) => {
            lineage.add(nodeId);
            const children = nodes.filter(n => n.parents.includes(nodeId) || (n.variant === nodes.find(node => node.id === nodeId).name));
            children.forEach(child => {
                lineage.add(child.id);
                getDescendants(child.id);
            });
        };
        getAncestors(d);
        getDescendants(d.id);
        node.classed("highlighted", n => lineage.has(n.id));
        link.classed("highlighted", l => lineage.has(l.source) && lineage.has(l.target));
    }
    function removeHighlightHoverLineage() {
        node.classed("highlighted", false);
        link.classed("highlighted", false);
    }
    function zoomToLineage(lineage) {
        const activeNodes = nodes.filter(n => lineage.has(n.id));
        const minX = d3.min(activeNodes, n => n.x) - standardPillWidth / 2;
        const maxX = d3.max(activeNodes, n => n.x) + standardPillWidth / 2;
        const minY = d3.min(activeNodes, n => n.y) - pillHeight / 2;
        const maxY = d3.max(activeNodes, n => n.y) + pillHeight / 2;
        const padding = 50;
        const currentTransform = d3.zoomTransform(svg.node());
        const currentScale = currentTransform.k;
        const currentViewport = {
            minX: -currentTransform.x / currentScale,
            minY: -currentTransform.y / currentScale,
            maxX: (-currentTransform.x + width) / currentScale,
            maxY: (-currentTransform.y + height) / currentScale
        };
        const isFullyVisible = minX >= currentViewport.minX &&
                               maxX <= currentViewport.maxX &&
                               minY >= currentViewport.minY &&
                               maxY <= currentViewport.maxY;
        if (!isFullyVisible) {
            const scale = Math.min(
                width / (maxX - minX + 2 * padding),
                height / (maxY - minY + 2 * padding)
            );
            const translate = [
                (width - scale * (maxX + minX)) / 2,
                (height - scale * (maxY + minY)) / 2
            ];
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(translate[0], translate[1])
                    .scale(scale));
        }
    }
    function resetZoom() {
        svg.transition()
            .duration(750)
            .call(zoom.transform, initialTransform);
    }
    const initialTransform = d3.zoomIdentity
        .translate(0, 0)
        .scale(0.4);
    svg.call(zoom.transform, initialTransform);
};
const getColorByDominance = (dominance) => {
    switch(dominance.toLowerCase()) {
        case 'sativa dominant': return '#ebdc70ff';
        case 'indica dominant': return '#adcbc9ff';
        case 'balanced hybrid': return '#ccd094ff';
        case 'unknown': return '#f3f6e8';
        default: return '#EAEAEA';
    }
};
const darkenColor = (color, amount) => d3.color(color).darker(amount / 10).toString();
const lightenColor = (color, amount) => d3.color(color).brighter(amount / 100).toString();

function setupStrainSearch() {
    const searchInput =

 document.getElementById('strainSearch');
    const dropdown = document.getElementById('strainDropdown');
    let strainList = strainData.map(strain => ({
        name: strain.Strain,
        product: strain.Product,
        alsoKnownAs: strain['Also Known As']
    })).filter(strain => !strain.name.toLowerCase().includes('unknown'));

    strainList.sort((a, b) => a.name.localeCompare(b.name));

    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        const filteredStrains = strainList.filter(strain => 
            strain.name.toLowerCase().includes(searchTerm) || 
            (strain.alsoKnownAs && strain.alsoKnownAs.toLowerCase().includes(searchTerm))
        );

        dropdown.innerHTML = '';
        filteredStrains.forEach(strain => {
            const div = document.createElement('div');
            let displayText = strain.name;
            if (strain.product) {
                displayText += `<br>(${strain.product})`;
            }
            if (strain.alsoKnownAs) {
                displayText += `<br>Also known as: ${strain.alsoKnownAs}`;
            }
            div.innerHTML = displayText;
            div.addEventListener('click', () => highlightStrain(strain.name));
            dropdown.appendChild(div);
        });

        dropdown.style.display = filteredStrains.length > 0 ? 'block' : 'none';
    });

    document.addEventListener('click', function(event) {
        if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
            dropdown.style.display = 'none';
        }
    });
}

function highlightStrain(strainName) {
    const node = d3.select(`.node:has(text:contains("${strainName}"))`);
    if (!node.empty()) {
        // Remove existing arrows
        d3.selectAll('.highlight-arrow').remove();

        // Add new arrow
        const arrow = node.append('path')
            .attr('class', 'highlight-arrow')
            .attr('d', 'M -120 0 L -80 -20 L -80 20 Z')
            .attr('fill', 'red')
            .attr('transform', 'scale(3)');

        // Position the arrow
        const nodeRect = node.select('rect');
        const rectX = parseFloat(nodeRect.attr('x'));
        const rectY = parseFloat(nodeRect.attr('y'));
        const rectWidth = parseFloat(nodeRect.attr('width'));
        const rectHeight = parseFloat(nodeRect.attr('height'));

        arrow.attr('transform', `translate(${rectX - 30},${rectY + rectHeight / 2}) scale(0.5)`);

        // Zoom to the node
        const nodeBBox = node.node().getBBox();
        const scale = 0.8 / Math.max(nodeBBox.width / svg.attr("width"), nodeBBox.height / svg.attr("height"));
        const translate = [
            svg.attr("width") / 2 - scale * (nodeBBox.x + nodeBBox.width / 2),
            svg.attr("height") / 2 - scale * (nodeBBox.y + nodeBBox.height / 2)
        ];

        svg.transition()
            .duration(750)
            .call(
                d3.zoom().transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );

        // Set up event listeners to remove the arrow
        node.on('click', function() {
            arrow.remove();
        });

        arrow.on('mouseover', function() {
            arrow.remove();
        });
    }

    // Close the dropdown
    document.getElementById('strainDropdown').style.display = 'none';
}

fetchData();

document.querySelectorAll('.btn').forEach((btn, index) => {
    btn.addEventListener('click', () => {
        document.getElementById(`popup${index + 1}`).style.display = 'block';
        document.querySelector('.popup-overlay').style.display = 'block';
    });
});

document.querySelector('.popup-overlay').addEventListener('click', () => {
    document.querySelectorAll('.popup').forEach(popup => popup.style.display = 'none');
    document.querySelector('.popup-overlay').style.display = 'none';
});
</script>
</body>
</html>