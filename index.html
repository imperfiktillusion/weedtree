<html><head><base href="https://imperfiktillusion.github.io/weedtree/">
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8527SLLPYV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8527SLLPYV');
</script>
<title>WeedTree Strain Lineage Chart</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 850 850"><path fill="%2391C83E" d="M39.6 362.6C39.6 184.2 210.3 39.6 420.9 39.6c210.5 0 381.2 144.6 381.2 323 0 178.4-170.7 323-381.2 323-210.6 0-381.3-144.6-381.3-323z"/><path fill="%236FAC43" d="M503.2 266c0-18.6 17.8-33.7 39.7-33.7 22 0 39.7 15.1 39.7 33.7 0 18.6-17.8 33.7-39.7 33.7-22 0-39.7-15.1-39.7-33.7zm-244.2 0c0-18.6 17.8-33.7 39.7-33.7 21.9 0 39.7 15.1 39.7 33.7 0 18.6-17.8 33.7-39.7 33.7-21.9 0-39.7-15.1-39.7-33.7z"/><path fill="none" stroke="%23444" stroke-width="79.2" stroke-linejoin="round" stroke-miterlimit="8" d="M503.2 266c0-18.6 17.8-33.7 39.7-33.7 22 0 39.7 15.1 39.7 33.7 0 18.6-17.8 33.7-39.7 33.7-22 0-39.7-15.1-39.7-33.7zm-244.2 0c0-18.6 17.8-33.7 39.7-33.7 21.9 0 39.7 15.1 39.7 33.7 0 18.6-17.8 33.7-39.7 33.7-21.9 0-39.7-15.1-39.7-33.7zm-44.8 237.5c137.8 80.2 275.3 80.2 412.7 0M39.6 362.6C39.6 184.2 210.3 39.6 420.9 39.6c210.5 0 381.2 144.6 381.2 323 0 178.4-170.7 323-381.2 323-210.6 0-381.3-144.6-381.3-323z"/></svg>' />
<style>
body,html{font-family:'Poppins',Arial,sans-serif;background-color:#fff;margin:0;padding:0;font-size:14px;height:100%;overflow:hidden}.header-ribbon{background-color:#434343;color:#fff;padding:10px;display:flex;justify-content:space-between;align-items:center}.header-ribbon h1{margin:0;font-size:1.8em;color:#fff;margin-left:6px}.subhead{font-size:.4em;font-weight:400;margin-left:3px}.container{height:calc(100vh - 50px);display:flex;flex-direction:column}.chart-container{flex-grow:1;width:100%;overflow:hidden}#lineageChart{width:100%;height:100%}.header-buttons{display:flex;gap:10px;align-items:center}.btn{background-color:transparent;color:#fff;padding:5px 15px;border:2px solid #fff;border-radius:18px;cursor:pointer;font-size:0.9em;font-family:'Poppins',Arial,sans-serif;transition:all .3s ease;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}.btn:hover{background-color:rgba(255,255,255,.1)}.node text{font-size:10px;fill:#434343;text-anchor:start;dominant-baseline:middle;font-family:'Poppins',Arial,sans-serif;font-weight:700}.node text.product{font-size:12px;font-weight:400}.node.dimmed rect{opacity:.1}.node.dimmed text{opacity:.1}.node.dimmed use{opacity:.1}.link.dimmed{opacity:.1}.node.highlighted rect{stroke:#f0f;stroke-width:3px}.link.highlighted{stroke:#f0f!important;stroke-width:3px}.node.clicked rect{stroke:#f0f;stroke-width:8px}.popup{position:fixed;top:50%;left:50%;transform:translate(-50%,-46%);width:80%;height:80%;background-color:#fff;border:2px solid #434343;border-radius:8px;z-index:1000;display:none;overflow:auto;padding:20px}.popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);z-index:999;display:none}#loading-message{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(255,255,255,0.8);padding:20px;border-radius:10px;z-index:1001;display:none}#strainSearch{background-color:transparent;color:#fff;padding:5px 15px;border:2px solid #fff;border-radius:18px;font-size:.9em;font-family:'Poppins',Arial,sans-serif;transition:all .3s ease;width:180px}#strainSearch::placeholder{color:rgba(255,255,255,0.7)}#strainSearch:focus{outline:none;background-color:rgba(255,255,255,0.1)}#strainDropdown{position:absolute;background-color:#fff;border:1px solid #ccc;max-height:400px;overflow-y:auto;display:none;z-index:1000;width:210px;box-shadow:1 4px 8px rgba(0,0,0,0.1);border-radius:0 0 4px 4px}#strainDropdown div{padding:5px 10px;cursor:pointer;transition:background-color 0.2s;color:#434343;font-size:8pt;line-height:1.2}#strainDropdown div:hover{background-color:#f0f0f0}.search-container{position:relative}.node.highlighted-search .highlight-arrow{fill:red}#centerLine {position: fixed;top: 0;left: 0;width: 100%;height: 100%;pointer-events: none;}.fullscreen-button-container {position: absolute;top: 70px;right: 10px;z-index: 997;}.fullscreen-button-container button {background-color: white;color: #cccccc;padding: 3px 5px;border: 2px solid #cccccc;border-radius: 0;cursor: pointer;font-size: 0.3em;font-family: 'Poppins', Arial, sans-serif;transition: all 0.3s ease;}.fullscreen-button-container button:hover {background-color: #f0f0f0;}.node{transition: transform 0.0s ease;}
</style>
<script src="https://d3js.org/d3.v6.min.js"></script>
<body>
<div class="header-ribbon">
    <h1>WeedTree Strain Lineage Chart <span class="subhead">Work in progress, errors probable</span></h1>
    <div class="header-buttons">
        <div class="search-container">
            <input type="text" id="strainSearch" placeholder="Locate strain">
            <div id="strainDropdown"></div>
        </div>
        <button id="btn1" class="btn">Filter Strains</button>
        <button id="btn2" class="btn">My Strains</button>
        <button id="btn3" class="btn">About</button>
    </div>
</div>
<div class="fullscreen-button-container">
    <button id="fullscreenToggle" class="btn">Toggle Full Screen</button>
</div>
<div class="container">
    <div class="chart-container">
        <div id="lineageChart"></div>
    </div>
</div>
<div class="popup-overlay"></div>
<div id="popup1" class="popup">
    <h2>Filter the chart - coming soon</h2>
    <p>A filter to show only the lineage of strains you're interest in is coming as soon as I can get it working.</p></div>
<div id="popup2" class="popup"><h5>Record and rate your strains - coming soon</h5></div>
<div id="popup3" class="popup">
    <h2>About WeedTree</h2>
    <p>I've always wondered how strain lineage correlated with the strains I personally prefer. Indica vs Sativa, Kush vs Afghani, Skunk vs Thai. I haven't been able to find much of a lineage chart anywhere online so decided to create one myself. I don't claim that the chart is completely accurate, it is based on what I could interpret from the multitude of often contradictory strain database sites internationally, and I've made some simplifications around phenotype/cultivar/clone/variant pedigree.</p>
    <p>Join me on Discord or Reddit <a href="https://www.reddit.com/user/imperfikt_illusion/"><b>u/imperfikt_illusion</b></a> to share knowledge or help grow the project</p>
    <p>Push F11 to toggle full screen.</br> Click on a strain to isolate its lineage.</br>A filter to show only the lineage of strains you're interested in is coming as soon as I can get it working.</br></p>
    <p>
</div>
<div id="loading-message">Loading strain data, please wait...</div>
<div id="centerLine"></div>
<svg id="nzIconTemplate" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" style="display: none;">
  <symbol id="nzIcon">
    <circle cx="14" cy="14" r="12.5" fill="white" stroke="black" stroke-width="0"/>
    <line x1="7.5" y1="9" x2="7.5" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="7.5" y1="9" x2="13" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="13" y1="9" x2="13" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="16" y1="9" x2="21.5" y2="9" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="16" y1="19" x2="21.5" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
    <line x1="21.5" y1="9" x2="16" y2="19" stroke="black" stroke-width="3" stroke-linecap="round"/>
  </symbol>
</svg>
<script>
let strainData = [], attributes = [], nodes = [], svg, g;
const showError = (message) => {
    document.getElementById('loading-message').style.display = 'none';
    alert(message);
};
function fetchData() {
    document.getElementById('loading-message').style.display = 'block';
    fetch('https://docs.google.com/spreadsheets/d/e/2PACX-1vSoTjN6psMidKhKOaAxqcZQQ_ArKkUTuRgn65c3ncNqjdLASER0J-Z3WYxFNuhFX_gDVoyHyH1PcCZy/pubhtml?gid=1070299978&single=true')
        .then(response => response.text())
        .then(html => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const table = doc.querySelector('table');
            if (!table) {
                showError("No table found in the spreadsheet.");
                return;
            }
            const rows = Array.from(table.querySelectorAll('tr')).filter(row => row.textContent.trim() !== '');
            if (rows.length < 2) {
                showError("Not enough data in the spreadsheet.");
                return;
            }
            const headerRowIndex = rows.findIndex(row => row.querySelector('td').textContent.trim() === 'Strain');
            if (headerRowIndex === -1) {
                showError("Could not find a row starting with 'Strain'.");
                return;
            }
            attributes = Array.from(rows[headerRowIndex].querySelectorAll('td')).map(td => td.textContent.trim());
            strainData = rows.slice(headerRowIndex + 1).map(row => {
                let obj = {};
                Array.from(row.querySelectorAll('td')).forEach((td, index) => {
                    obj[attributes[index]] = td.textContent.trim();
                });
                return obj;
            }).filter(obj => Object.values(obj).some(value => value !== ''));
            document.getElementById('loading-message').style.display = 'none';
            createLineageChart();
            setupStrainSearch();
        })
        .catch(error => {
            showError("Error fetching data: " + error.message);
        });
}

function customSortColumn2(a, b) {
    const dominanceOrder = {
        'indica dominant': 0,
        'balanced hybrid': 1,
        'unknown': 2,
        'sativa dominant': 3
    };

    const indicaOrder = [
        'Afghan/Pakistan Indica Landraces',
        'Purple Afghan Indica Landraces',
        'Hindu Kush Landraces',
        'Nepalese Indica Landraces',
        'North American Indica Landraces'
    ];

    const sativaOrder = [
        'South India Sativa Landraces',
        'Burmese Sativa Landraces',
        'Cambodia Sativa Landraces',
        'Thai Sativa Landraces',
        'Chocolate Thai Sativa Landraces',
        'Purple Thai Sativa Landraces',
        'Indonesia Sativa Landraces',
        'North African Sativa Landraces',
        'East African Sativa landraces',
        'South African Sativa Landraces',
        'Jamaican Sativa Landraces',
        'California Sativa Landraces',
        'Mexico Sativa Landraces',
        'Panama Sativa Landraces',
        'Colombian Sativa Landraces',
        'Brazil Sativa Landraces',
        'Hawaiian Sativa Landraces'
    ];

    if (a.dominance.toLowerCase() !== b.dominance.toLowerCase()) {
        return dominanceOrder[a.dominance.toLowerCase()] - dominanceOrder[b.dominance.toLowerCase()];
    }

    if (a.dominance.toLowerCase() === 'indica dominant') {
        const aIndex = indicaOrder.indexOf(a.name);
        const bIndex = indicaOrder.indexOf(b.name);
        if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
        }
        if (aIndex !== -1) return -1;
        if (bIndex !== -1) return 1;
    }

    if (a.dominance.toLowerCase() === 'sativa dominant') {
        const aIndex = sativaOrder.indexOf(a.name);
        const bIndex = sativaOrder.indexOf(b.name);
        if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
        }
        if (aIndex !== -1) return -1;
        if (bIndex !== -1) return 1;
    }

    return a.name.localeCompare(b.name);
}

function customSortColumn3Plus(a, b) {
    const dominanceOrder = {
        'indica dominant': 0,
        'balanced hybrid': 1,
        'unknown': 2,
        'sativa dominant': 3
    };

    if (a.dominance.toLowerCase() !== b.dominance.toLowerCase()) {
        return dominanceOrder[a.dominance.toLowerCase()] - dominanceOrder[b.dominance.toLowerCase()];
    }

    return a.name.localeCompare(b.name);
}

function calculateColumn1Positions() {
    const column1Nodes = nodes.filter(n => n.generation === 0);
    column1Nodes.forEach(node => {
        const children = nodes.filter(n => n.parents.includes(node.id));
        if (children.length > 0) {
            const avgY = d3.mean(children, d => d.y);
            node.y = avgY;
        }
    });
}

const createLineageChart = () => {
    const chartContainer = document.querySelector('.chart-container');
    const width = chartContainer.clientWidth, height = chartContainer.clientHeight;
    d3.select("#lineageChart").selectAll("*").remove();
    svg = d3.select("#lineageChart").append("svg").attr("width", width).attr("height", height);
    g = svg.append("g");
    const zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => g.attr("transform", event.transform));
    svg.call(zoom);
    
    nodes = strainData.map(strain => ({
        id: strain.Strain,
        name: strain.Strain,
        displayName: strain.Strain,
        dominance: strain.Dominance,
        parents: [strain.Parent1, strain.Parent2, strain.Parent3, strain.Parent4].filter(p => p),
        generation: 0,
        special: strain.Special,
        product: strain.Product,
        variant: strain.Variant,
        alsoKnownAs: strain['Also Known As']
    }));

    const hasChildren = new Set(nodes.flatMap(node => node.parents));
    nodes = nodes.filter(node => 
        hasChildren.has(node.name) || node.parents.length > 0 || node.special || node.variant
    );

    nodes.forEach(node => {
        if (node.name.toLowerCase().includes('unknown')) {
            node.displayName = node.name.replace(/\d+/g, '');
        }
    });

    const links = [];
    nodes.forEach(node => {
        if (node.variant) {
            const parentNode = nodes.find(n => n.name === node.variant);
            if (parentNode) links.push({ source: parentNode.id, target: node.id });
        } else {
            node.parents.forEach(parent => {
                if (parent && nodes.some(n => n.id === parent)) links.push({ source: parent, target: node.id });
            });
        }
    });

    const assignGenerations = () => {
        let changed = true;
        while (changed) {
            changed = false;
            nodes.forEach(node => {
                if (node.special && node.special.toLowerCase() === 'origin') {
                    if (node.generation !== 0) {
                        node.generation = 0;
                        changed = true;
                    }
                } else if (node.special && node.special.toLowerCase() === 'landrace') {
                    if (node.generation !== 1) {
                        node.generation = 1;
                        changed = true;
                    }
                } else if (node.variant) {
                    const parentNode = nodes.find(n => n.name === node.variant);
                    if (parentNode && node.generation !== parentNode.generation) {
                        node.generation = parentNode.generation;
                        changed = true;
                    }
                } else {
                    const parentGens = node.parents.map(parentId => {
                        const parent = nodes.find(n => n.id === parentId);
                        return parent ? parent.generation : -1;
                    }).filter(gen => gen !== -1);
                    if (parentGens.length > 0) {
                        const maxParentGen = Math.max(...parentGens);
                        if (node.generation !== maxParentGen + 1) {
                            node.generation = maxParentGen + 1;
                            changed = true;
                        }
                    }
                }
            });
        }

        let specialCaseChanged = true;
        while (specialCaseChanged) {
            specialCaseChanged = false;
            nodes.forEach(node => {
                if (node.name.toLowerCase().includes('unknown') || 
                    (node.parents.length > 0 && node.parents.every(parentId => {
                        const parent = nodes.find(n => n.id === parentId);
                        return parent && parent.name.toLowerCase().includes('unknown');
                    }))) {
                    const children = nodes.filter(n => n.parents.includes(node.id));
                    if (children.length > 0) {
                        const minChildGen = Math.min(...children.map(c => c.generation));
                        const newGen = minChildGen - 1;
                        if (node.generation !== newGen) {
                            node.generation = newGen;
                            specialCaseChanged = true;
                        }
                    }
                }
            });
        }
    };
    assignGenerations();

    const maxWidth = Math.max(...nodes.map(d => d.displayName.length * 7));
    const standardPillWidth = Math.max(maxWidth, 150);
    const pillHeight = 30, lineWidth = 2;
    const maxGeneration = Math.max(...nodes.map(n => n.generation));
    const columnWidth = Math.max(width / (maxGeneration + 1), standardPillWidth * 1.6);

    const column2Nodes = nodes.filter(n => n.generation === 1 && !n.variant);
    column2Nodes.sort(customSortColumn2);

    for (let gen = 0; gen <= maxGeneration + 1; gen++) {
        let genNodes = nodes.filter(n => 
            (n.generation === gen) || 
            (gen === 1 && n.special && n.special.toLowerCase() === 'landrace')
        );

        if (gen === 1) {
            genNodes = column2Nodes.concat(genNodes.filter(n => !column2Nodes.includes(n)));
        } else if (gen >= 2) {
            genNodes.sort(customSortColumn3Plus);
        }

        let yOffset = 0;
        const totalHeight = genNodes.filter(n => !n.variant).length * (pillHeight + 10) +
                            genNodes.filter(n => n.variant).length * (pillHeight + 2);
        const startY = (height - totalHeight) / 2;

        genNodes.forEach((node, index) => {
            node.x = gen * columnWidth; // Set x position based on generation
            if (!node.variant) {
                if (gen !== 0 || node.y === undefined) {
                    node.y = startY + yOffset;
                }
                yOffset += pillHeight + 16; // min gap between standard nodes

                const variants = nodes.filter(n => n.variant === node.name).sort((a, b) => a.name.localeCompare(b.name));
                variants.forEach((variant, vIndex) => {
                    variant.y = node.y + (vIndex + 1) * (pillHeight + 2);
                    variant.x = node.x;
                });

                yOffset += variants.length * (pillHeight + 2);
            }
        });
    }

    calculateColumn1Positions();

    const link = g.append("g")
        .selectAll("path")
        .data(links)
        .join("path")
        .attr("class", "link")
        .attr("stroke", d => darkenColor(getColorByDominance(nodes.find(n => n.id === d.source).dominance), 0))
        .attr("stroke-opacity", 1)
        .attr("stroke-width", lineWidth + 1) 
        .attr("fill", "none")
        .attr("d", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target);
            const sourcePillWidth = sourceNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
            const targetPillWidth = targetNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
            const sourceX = sourceNode.x + sourcePillWidth / 2;
            const targetX = targetNode.x - targetPillWidth / 2;
            const midX = (sourceX + targetX) / 2;
            return `M${sourceX},${sourceNode.y} C${midX},${sourceNode.y} ${midX},${targetNode.y} ${targetX},${targetNode.y}`;
        });

    const node = g.append("g")
        .selectAll("g")
        .data(nodes)
        .join("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .on("click", highlightLineage)
        .on("mouseover", function(event, d) {
            highlightHoverLineage(event, d);
            d3.select(this).raise().transition()
                .attr("transform", d => `translate(${d.x},${d.y}) scale(1.7, 1.7)`);
        })
        .on("mouseout", function(event, d) {
            removeHighlightHoverLineage();
            d3.select(this).transition()
                .attr("transform", d => `translate(${d.x},${d.y}) scale(1)`);
        });

    node.append("rect")
        .attr("rx", pillHeight / 2)
        .attr("ry", pillHeight / 2)
        .attr("width", d => d.variant ? standardPillWidth * 0.85 : standardPillWidth)
        .attr("height", pillHeight)
        .attr("fill", d => {
            if (d.variant) {
                switch(d.dominance.toLowerCase()) {
                    case 'indica dominant': return '#eff5f5';
                    case 'sativa dominant': return '#faf8e1';
                    case 'balanced hybrid': return '#f3f6e8';
                    case 'unknown': return '#f3f6e8';
                    default: return 'gray';
                }
            } else {
                return getColorByDominance(d.dominance);
            }
        })
        .attr("x", d => d.variant ? -(standardPillWidth * 0.85) / 2 : -standardPillWidth / 2)
        .attr("y", -pillHeight / 2)
        .attr("stroke", d => d.product ? "black" : getColorByDominance(d.dominance))
        .attr("stroke-width", d => d.product ? 3 : 2);

    node.sort((a, b) => (a.product ? 1 : 0) - (b.product ? 1 : 0));

    node.append("text")
        .attr("class", "strain-name")
        .text(d => d.displayName)
        .attr("x", d => d.variant ? -(standardPillWidth * 0.85) / 2 + 12 : -standardPillWidth / 2 + 12) 
        .attr("y", 1)
        .attr("dominant-baseline", "middle")
        .attr("fill", "black")
        .style("font-size", "12px")
        .style("font-family", "'Poppins', Arial, sans-serif")
        .style("font-weight", "bold");

    node.filter(d => d.product)
        .append("use")
        .attr("href", "#nzIcon")
        .attr("width", 30)
        .attr("height", 30)
        .attr("x", function(d) {
            const nodeWidth = d.variant ? standardPillWidth * 0.85 : standardPillWidth;
            return nodeWidth / 2 - 29; 
        })
        .attr("y", -14);

    node.append("text")
        .filter(d => d.product)
        .text(d => d.product)
        .attr("class", "product")
        .attr("x", function(d) {
            const strainNameWidth = this.parentNode.querySelector('.strain-name').getComputedTextLength();
            const nodeWidth = d.variant ? standardPillWidth * 0.85 : standardPillWidth;
            return -nodeWidth / 2 + 5 + strainNameWidth + 10;
        })
        .attr("y", 1.6)
        .attr("dominant-baseline", "middle")
        .attr("fill", "black")
        .style("font-size", "10px")
        .style("font-family", "'Poppins', Arial, sans-serif")
        .style("font-weight", "normal");

    let focusedNode = null;

    function highlightLineage(event, d) {
        if (focusedNode === d) {
            node.classed("dimmed", false);
            node.classed("clicked", false);
            link.classed("dimmed", false)
                .attr("stroke-width", lineWidth + 1);
            focusedNode = null;
            resetZoom();
        } else {
            const lineage = new Set();
            const getAncestors = (node) => {
                lineage.add(node.id);
                if (node.variant) {
                    const parentNode = nodes.find(n => n.name === node.variant);
                    if (parentNode) {
                        lineage.add(parentNode.id);
                        getAncestors(parentNode);
                    }
                } else {
                    node.parents.forEach(parentId => {
                        const parent = nodes.find(n => n.id === parentId);
                        if (parent) {
                            lineage.add(parentId);
                            getAncestors(parent);
                        }
                    });
                }
            };
            const getDescendants = (nodeId) => {
                lineage.add(nodeId);
                const children = nodes.filter(n => n.parents.includes(nodeId) || (n.variant === nodes.find(node => node.id === nodeId).name));
                children.forEach(child => {
                    lineage.add(child.id);
                    getDescendants(child.id);
                });
            };
            getAncestors(d);
            getDescendants(d.id);
            node.classed("dimmed", n => !lineage.has(n.id));
            node.classed("clicked", n => n.id === d.id);
            link.classed("dimmed", l => !lineage.has(l.source) || !lineage.has(l.target))
                .attr("stroke-width", l => 
                    (lineage.has(l.source) && lineage.has(l.target)) ? lineWidth + 2 : lineWidth + 1
                );
            focusedNode = d;
            zoomToLineage(lineage);
        }
        d3.select(this).select('.highlight-arrow').remove();
    }

    function highlightHoverLineage(event, d) {
        const lineage = new Set();
        const getAncestors = (node) => {
            lineage.add(node.id);
            if (node.variant) {
                const parentNode = nodes.find(n => n.name === node.variant);
                if (parentNode) {
                    lineage.add(parentNode.id);
                    getAncestors(parentNode);
                }
            } else {
                node.parents.forEach(parentId => {
                    const parent = nodes.find(n => n.id === parentId);
                    if (parent) {
                        lineage.add(parentId);
                        getAncestors(parent);
                    }
                });
            }
        };
        const getDescendants = (nodeId) => {
            lineage.add(nodeId);
            const children = nodes.filter(n => n.parents.includes(nodeId) || (n.variant === nodes.find(node => node.id === nodeId).name));
            children.forEach(child => {
                lineage.add(child.id);
                getDescendants(child.id);
            });
        };
        getAncestors(d);
        getDescendants(d.id);
        node.classed("highlighted", n => lineage.has(n.id));
        link.classed("highlighted", l => lineage.has(l.source) && lineage.has(l.target));
    }

    function removeHighlightHoverLineage() {
        node.classed("highlighted", false);
        link.classed("highlighted", false);
    }

    function zoomToLineage(lineage) {
        const activeNodes = nodes.filter(n => lineage.has(n.id));
        const minX = d3.min(activeNodes, n => n.x) - standardPillWidth / 2;
        const maxX = d3.max(activeNodes, n => n.x) + standardPillWidth / 2;
        const minY = d3.min(activeNodes, n => n.y) - pillHeight / 2;
        const maxY = d3.max(activeNodes, n => n.y) + pillHeight / 2;
        const padding = 50;

        const scale = Math.min(
            width / (maxX - minX + 2 * padding),
            height / (maxY - minY + 2 * padding)
        );

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const translate = [
            width / 2 - scale * centerX,
            height / 2 - scale * centerY
        ];

        svg.transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity
                .translate(translate[0], translate[1])
                .scale(scale));
    }

    function resetZoom() {
        svg.transition()
            .duration(750)
            .call(zoom.transform, calculateInitialTransform());
    }

    function calculateInitialTransform() {
        const padding = 50;
        const minX = d3.min(nodes, n => n.x) - standardPillWidth / 2;
        const maxX = d3.max(nodes, n => n.x) + standardPillWidth / 2;
        const minY = d3.min(nodes, n => n.y) - pillHeight / 2;
        const maxY = d3.max(nodes, n => n.y) + pillHeight / 2;

        const scale = Math.min(
            width / (maxX - minX + 2 * padding),
            height / (maxY - minY + 2 * padding)
        );

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const translateX = width / 2 - scale * centerX;
        const translateY = height / 2 - scale * centerY;

        return d3.zoomIdentity
            .translate(translateX, translateY)
            .scale(scale);
    }

    const initialTransform = calculateInitialTransform();
    svg.call(zoom.transform, initialTransform);
};

const getColorByDominance = (dominance) => {
    switch(dominance.toLowerCase()) {
        case 'sativa dominant': return '#ebdc70ff';
        case 'indica dominant': return '#adcbc9ff';
        case 'balanced hybrid': return '#ccd094ff';
        case 'unknown': return '#f3f6e8';
        default: return '#EAEAEA';
    }
};

const darkenColor = (color, amount) => d3.color(color).darker(amount / 10).toString();
const lightenColor = (color, amount) => d3.color(color).brighter(amount / 100).toString();

function setupStrainSearch() {
    const searchInput = document.getElementById('strainSearch');
    const dropdown = document.getElementById('strainDropdown');
    let highlightedNode = null;

    searchInput.addEventListener('input', function() {
        const searchText = this.value.toLowerCase();
        if (searchText.length === 0) {
            dropdown.style.display = 'none';
            return;
        }

        const matchingStrains = nodes.filter(node => 
            !node.name.toLowerCase().includes('unknown') && (
                node.name.toLowerCase().includes(searchText) ||
                (node.product && node.product.toLowerCase().includes(searchText)) ||
                (node.alsoKnownAs && node.alsoKnownAs.toLowerCase().includes(searchText))
            )
        );

        dropdown.innerHTML = '';
        matchingStrains.sort((a, b) => a.name.localeCompare(b.name)).forEach(strain => {
            const div = document.createElement('div');
            div.innerHTML = strain.name + 
                            (strain.product ? `<br>(${strain.product})` : '') + 
                            (strain.alsoKnownAs ? ` [${strain.alsoKnownAs}]` : '');
            div.addEventListener('click', () => {
                highlightStrain(strain);
                dropdown.style.display = 'none';
                searchInput.value = '';
            });
            dropdown.appendChild(div);
        });

        dropdown.style.display = matchingStrains.length > 0 ? 'block' : 'none';
    });

    document.addEventListener('click', function(event) {
        if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
            dropdown.style.display = 'none';
        }
    });

    function highlightStrain(strain) {
        if (highlightedNode) {
            d3.select(highlightedNode).select('.highlight-arrow').remove();
            highlightedNode = null;
        }

        const node = g.selectAll('.node').filter(d => d.id === strain.id);
        const arrow = node.append('path')
            .attr('d', 'M-70,-6 L-39,0 L-70,6 Z')
            .attr('class', 'highlight-arrow')
            .attr('fill', 'red')
            .attr('transform', 'translate(0,0) scale(3)');

        arrow.on('mouseover', function() {
            d3.select(this).remove();
            highlightedNode = null;
        });

        arrow.on('click', function(event) {
            event.stopPropagation();
        });

        highlightedNode = node.node();

        zoomToNode(strain);
    }

    function zoomToNode(strain) {
        const transform = d3.zoomTransform(svg.node());
        const scale = 2;
        const x = -strain.x * scale + svg.attr('width') / 2;
        const y = -strain.y * scale + svg.attr('height') / 2;

        svg.transition()
            .duration(750)
            .call(d3.zoom().transform, d3.zoomIdentity.translate(x, y).scale(scale));
    }
}
window.onload = function() {
    fetchData();
};

document.getElementById('fullscreenToggle').addEventListener('click', toggleFullScreen);
function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

window.addEventListener('resize', function() {
    createLineageChart();
    adjustFullscreenButtonPosition();
    adjustButtonFontSize();
});

function adjustFullscreenButtonPosition() {
    const ribbon = document.querySelector('.header-ribbon');
    const fullscreenButton = document.querySelector('.fullscreen-button-container');
    if (ribbon && fullscreenButton) {
        const ribbonHeight = ribbon.offsetHeight;
        fullscreenButton.style.top = (ribbonHeight + 10) + 'px';
    }
}

function adjustButtonFontSize() {
    const buttons = document.querySelectorAll('.btn');
    const headerButtons = document.querySelector('.header-buttons');
    const availableWidth = headerButtons.offsetWidth;
    let totalButtonWidth = 0;

    buttons.forEach(button => {
        button.style.fontSize = '0.9em'; // Reset to original size
        totalButtonWidth += button.offsetWidth;
    });

    if (totalButtonWidth > availableWidth) {
        const scaleFactor = availableWidth / totalButtonWidth;
        buttons.forEach(button => {
            const newSize = parseFloat(getComputedStyle(button).fontSize) * scaleFactor;
            button.style.fontSize = `${newSize}px`;
        });
    }
}

window.addEventListener('load', adjustButtonFontSize);

['btn1', 'btn2', 'btn3'].forEach(id => 
    document.getElementById(id).addEventListener('click', () => togglePopup(`popup${id.replace('btn', '')}`))
);

const togglePopup = (popupId) => {
    const popup = document.getElementById(popupId);
    const overlay = document.querySelector('.popup-overlay');
    const allPopups = document.querySelectorAll('.popup');
    allPopups.forEach(p => { if (p.id !== popupId) p.style.display = 'none'; });
    if (popup.style.display === 'block') {
        popup.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        popup.style.display = 'block';
        overlay.style.display = 'block';
    }
};

document.querySelector('.popup-overlay').addEventListener('click', function() {
    document.querySelectorAll('.popup').forEach(popup => popup.style.display = 'none');
    this.style.display = 'none';
});

document.querySelectorAll('.popup').forEach(popup => 
    popup.addEventListener('click', event => event.stopPropagation())
);
</script>
</body>
</html>
