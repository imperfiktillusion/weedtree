<html><head><base href="https://www.weedtree.com/strain_lineage_chart">
<title>WeedTree Strain Lineage Chart</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='11' fill='%238cd82d' stroke='%23434343' stroke-width='3'/%3E%3Ccircle cx='8' cy='9' r='4' fill='%23434343'/%3E%3Ccircle cx='16' cy='9' r='4' fill='%23434343'/%3E%3Cpath d='M7 14.5C8 16.5 10 18 12 18s4-1.5 5-3.5' fill='none' stroke='%23434343' stroke-width='3' stroke-linecap='round'/%3E%3C/svg%3E">
<style>
body,html{font-family:'Poppins',Arial,sans-serif;background-color:#fff;margin:0;padding:0;font-size:14px;height:100%;overflow:hidden}.header-ribbon{background-color:#434343;color:#fff;padding:10px;display:flex;justify-content:space-between;align-items:center}.header-ribbon h1{margin:0;font-size:1.8em;color:#fff;margin-left:6px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.subhead{font-size:.4em;font-weight:400;margin-left:3px}.container{height:calc(100vh - 50px);display:flex;flex-direction:column}.chart-container{flex-grow:1;width:100%;overflow:hidden}#lineageChart{width:100%;height:100%}.header-buttons{display:flex;gap:10px;align-items:center}.btn{background-color:transparent;color:#fff;padding:5px 15px;border:2px solid #fff;border-radius:18px;cursor:pointer;font-size:.9em;font-family:'Poppins',Arial,sans-serif;transition:all .3s ease;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:0}.btn:hover{background-color:rgba(255,255,255,.1)}.node text{font-size:10px;fill:#434343;text-anchor:start;dominant-baseline:middle;font-family:'Poppins',Arial,sans-serif;font-weight:700}.node text.product{font-size:12px;font-weight:400}.node.dimmed rect{opacity:.15}.node.dimmed text{opacity:.15}.link.dimmed{opacity:.15}.node.highlighted rect{stroke:#f0f;stroke-width:3px}.link.highlighted{stroke:#f0f!important;stroke-width:3px}.node.clicked rect{stroke:#f0f;stroke-width:3px}.popup{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:94%;height:90%;background-color:#fff;border:2px solid #434343;border-radius:15px;z-index:1000;display:none;overflow:auto;padding:20px}.popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);z-index:999;display:none}#loading-message{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(255,255,255,0.8);padding:20px;border-radius:10px;z-index:1001;display:none}
#strainSearch{background-color:transparent;color:#fff;padding:5px 15px;border:2px solid #fff;border-radius:18px;font-size:.9em;font-family:'Poppins',Arial,sans-serif;transition:all .3s ease;width:180px;min-width:0}#strainSearch::placeholder{color:rgba(255,255,255,0.7)}#strainSearch:focus{outline:none;background-color:rgba(255,255,255,0.1)}#strainDropdown{position:absolute;background-color:#fff;border:1px solid #ccc;max-height:400px;overflow-y:auto;display:none;z-index:1000;width:210px;box-shadow:1 4px 8px rgba(0,0,0,0.1);border-radius:0 0 4px 4px}#strainDropdown div{padding:5px 10px;cursor:pointer;transition:background-color 0.2s;color:#434343;font-size:8pt;line-height:1.2}#strainDropdown div:hover{background-color:#f0f0f0}.search-container{position:relative}.node.highlighted-search .highlight-arrow{fill:red}
</style>
<script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
<div class="header-ribbon">
    <h1>WeedTree Strain Lineage Chart <span class="subhead">Work in progress, errors probable</span></h1>
    <div class="header-buttons">
        <div class="search-container">
            <input type="text" id="strainSearch" placeholder="Locate strain">
            <div id="strainDropdown"></div>
        </div>
        <button id="btn1" class="btn">Filter Strains</button>
        <button id="btn2" class="btn">My Strains</button>
        <button id="btn3" class="btn">About</button>
    </div>
</div>
<div class="container">
    <div class="chart-container">
        <div id="lineageChart"></div>
    </div>
</div>
<div class="popup-overlay"></div>
<div id="popup1" class="popup"><h2>Filter the chart - coming soon</h2></div>
<div id="popup2" class="popup"><h2>Record and rate your strains - coming soon</h2></div>
<div id="popup3" class="popup"><h2>coming soon</h2></div>
<div id="loading-message">Loading data, please wait...</div>
<script>
let strainData = [], attributes = [], nodes = [], svg, g;
const showError = (message) => {
    document.getElementById('loading-message').style.display = 'none';
    alert(message);
};
function fetchData() {
    document.getElementById('loading-message').style.display = 'block';
    fetch('https://docs.google.com/spreadsheets/d/e/2PACX-1vSoTjN6psMidKhKOaAxqcZQQ_ArKkUTuRgn65c3ncNqjdLASER0J-Z3WYxFNuhFX_gDVoyHyH1PcCZy/pubhtml?gid=1070299978&single=true')
        .then(response => response.text())
        .then(html => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const table = doc.querySelector('table');
            if (!table) {
                showError("No table found in the spreadsheet.");
                return;
            }
            const rows = Array.from(table.querySelectorAll('tr')).filter(row => row.textContent.trim() !== '');
            if (rows.length < 2) {
                showError("Not enough data in the spreadsheet.");
                return;
            }            
            const headerRowIndex = rows.findIndex(row => row.querySelector('td').textContent.trim() === 'Strain');
            if (headerRowIndex === -1) {
                showError("Could not find a row starting with 'Strain'.");
                return;
            }            
            attributes = Array.from(rows[headerRowIndex].querySelectorAll('td')).map(td => td.textContent.trim());
            strainData = rows.slice(headerRowIndex + 1).map(row => {
                let obj = {};
                Array.from(row.querySelectorAll('td')).forEach((td, index) => {
                    obj[attributes[index]] = td.textContent.trim();
                });
                return obj;
            }).filter(obj => Object.values(obj).some(value => value !== ''));
            document.getElementById('loading-message').style.display = 'none';
            createLineageChart();
            setupStrainSearch();
        })
        .catch(error => {
            showError("Error fetching data: " + error.message);
        });
}

const createLineageChart = () => {
    const chartContainer = document.querySelector('.chart-container');
    const width = chartContainer.clientWidth, height = chartContainer.clientHeight;
    d3.select("#lineageChart").selectAll("*").remove();
    svg = d3.select("#lineageChart").append("svg").attr("width", width).attr("height", height);
    g = svg.append("g");
    const zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => g.attr("transform", event.transform));
    svg.call(zoom);
    nodes = strainData.map(strain => ({
        id: strain.Strain,
        name: strain.Strain,
        displayName: strain.Strain,
        dominance: strain.Dominance,
        parents: [strain.Parent1, strain.Parent2, strain.Parent3, strain.Parent4].filter(p => p),
        generation: 0,
        special: strain.Special,
        product: strain.Product,
        variant: strain.Variant,
        alsoKnownAs: strain['Also Known As']
    }));
    const links = [];
    nodes.forEach(node => {
        if (node.variant) {
            const parentNode = nodes.find(n => n.name === node.variant);
            if (parentNode) links.push({ source: parentNode.id, target: node.id });
        } else {
            node.parents.forEach(parent => {
                if (parent && nodes.some(n => n.id === parent)) links.push({ source: parent, target: node.id });
            });
        }
    });

    // Filter out strains with no parents and no children
    const connectedNodes = new Set();
    links.forEach(link => {
        connectedNodes.add(link.source);
        connectedNodes.add(link.target);
    });
    nodes = nodes.filter(node => connectedNodes.has(node.id));

    const assignGenerations = () => {
        let changed = true;
        while (changed) {
            changed = false;
            nodes.forEach(node => {
                if (node.special && node.special.toLowerCase() === 'origin') {
                    if (node.generation !== 0) {
                        node.generation = 0;
                        changed = true;
                    }
                } else if (node.special && node.special.toLowerCase() === 'landrace') {
                    if (node.generation !== 1) {
                        node.generation = 1;
                        changed = true;
                    }
                } else if (node.variant) {
                    const parentNode = nodes.find(n => n.name === node.variant);
                    if (parentNode && node.generation !== parentNode.generation) {
                        node.generation = parentNode.generation;
                        changed = true;
                    }
                } else {
                    const parentGens = node.parents.map(parentId => {
                        const parent = nodes.find(n => n.id === parentId);
                        return parent ? parent.generation : -1;
                    }).filter(gen => gen !== -1);
                    if (parentGens.length > 0) {
                        const maxParentGen = Math.max(...parentGens);
                        if (node.generation !== maxParentGen + 1) {
                            node.generation = maxParentGen + 1;
                            changed = true;
                        }
                    }
                }
            });
        }
    };
    assignGenerations();
    const maxWidth = Math.max(...nodes.map(d => d.displayName.length * 7));
    const standardPillWidth = Math.max(maxWidth, 150);
    const pillHeight = 30, lineWidth = 2;
    const maxGeneration = Math.max(...nodes.map(n => n.generation));
    const columnWidth = Math.max(width / (maxGeneration + 1), standardPillWidth * 1.8);

    nodes.forEach(node => {
        if (node.special && node.special.toLowerCase() === 'origin') {
            node.x = columnWidth / 2;
        } else if (node.special && node.special.toLowerCase() === 'landrace') {
            node.x = columnWidth * 1.5;
        } else {
            node.x = (node.generation + 0) * columnWidth + columnWidth / 2;
        }
    });

    for (let gen = 0; gen <= maxGeneration + 1; gen++) {
        let genNodes = nodes.filter(n => 
            (n.generation === gen) || 
            (gen === 1 && n.special && n.special.toLowerCase() === 'landrace')
        );
        let yOffset = 0;
        genNodes.forEach((node, index) => {
            node.y = yOffset;
            yOffset += pillHeight + 10;
        });
    }

    const link = g.append("g")
        .selectAll("line")
        .data(links)
        .join("line")
        .attr("class", "link")
        .attr("stroke", d => darkenColor(getColorByDominance(nodes.find(n => n.id === d.source).dominance), 0))
        .attr("stroke-opacity", 1)
        .attr("stroke-width", lineWidth)
        .attr("x1", d => {
            const sourceNode = nodes.find(n => n.id === d.source);
            const pillWidth = sourceNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
            return sourceNode.x + pillWidth / 2;
        })
        .attr("y1", d => nodes.find(n => n.id === d.source).y)
        .attr("x2", d => {
            const targetNode = nodes.find(n => n.id === d.target);
            const pillWidth = targetNode.variant ? standardPillWidth * 0.85 : standardPillWidth;
            return targetNode.x - pillWidth / 2;
        })
        .attr("y2", d => nodes.find(n => n.id === d.target).y);
    const node = g.append("g")
        .selectAll("g")
        .data(nodes)
        .join("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .on("click", highlightLineage)
        .on("mouseover", highlightHoverLineage)
        .on("mouseout", removeHighlightHoverLineage);
    node.append("rect")
        .attr("rx", pillHeight / 2)
        .attr("ry", pillHeight / 2)
        .attr("width", d => d.variant ? standardPillWidth * 0.85 : standardPillWidth)
        .attr("height", pillHeight)
        .attr("fill", d => {
            if (d.variant) {
                switch(d.dominance.toLowerCase()) {
                    case 'indica dominant': return '#eff5f5';
                    case 'sativa dominant': return '#faf8e1';
                    case 'balanced hybrid': return '#f3f6e8';
                    case 'unknown': return '#f3f6e8';
                    default: return 'gray';
                }
            } else {
                return getColorByDominance(d.dominance);
            }
        })
        .attr("x", d => d.variant ? -(standardPillWidth * 0.85) / 2 : -standardPillWidth / 2)
        .attr("y", -pillHeight / 2)
        .attr("stroke", d => d.product ? "black" : getColorByDominance(d.dominance))
        .attr("stroke-width", 2);
    node.append("text")
        .attr("class", "strain-name")
        .text(d => d.displayName)
        .attr("x", d => d.variant ? -(standardPillWidth * 0.85) / 2 + 10 : -standardPillWidth / 2 + 10)
        .attr("y", "1px") // Move text lower
        .attr("dominant-baseline", "middle")
        .attr("fill", "black")
        .style("font-size", "12px")
        .style("font-family", "'Poppins', Arial, sans-serif")
        .style("font-weight", "bold");
    node.append("text")
        .filter(d => d.product)
        .text(d => d.product)
        .attr("class", "product")
        .attr("x", function(d) {
            const strainNameWidth = this.parentNode.querySelector('.strain-name').getComputedTextLength();
            return (d.variant ? -(standardPillWidth * 0.85) / 2 : -standardPillWidth / 2) + 3 + strainNameWidth + 10;
        })
        .attr("y", "1.7px") // Move text lower
        .attr("dominant-baseline", "middle")
        .attr("fill", "black")
        .style("font-size", "10px")
        .style("font-family", "'Poppins', Arial, sans-serif")
        .style("font-weight", "normal");
    let focusedNode = null;
    function highlightLineage(event, d) {
        if (focusedNode === d) {
            node.classed("dimmed", false);
            node.classed("clicked", false);
            link.classed("dimmed", false);
            focusedNode = null;
            resetZoom();
        } else {
            const lineage = new Set();
            const getAncestors = (node) => {
                lineage.add(node.id);
                if (node.variant) {
                    const parentNode = nodes.find(n => n.name === node.variant);
                    if (parentNode) {
                        lineage.add(parentNode.id);
                        getAncestors(parentNode);
                    }
                } else {
                    node.parents.forEach(parentId => {
                        const parent = nodes.find(n => n.id === parentId);
                        if (parent) {
                            lineage.add(parentId);
                            getAncestors(parent);
                        }
                    });
                }
            };
            const getDescendants = (nodeId) => {
                lineage.add(nodeId);
                const children = nodes.filter(n => n.parents.includes(nodeId) || (n.variant === nodes.find(node => node.id === nodeId).name));
                children.forEach(child => {
                    lineage.add(child.id);
                    getDescendants(child.id);
                });
            };
            getAncestors(d);
            getDescendants(d.id);
            node.classed("dimmed", n => !lineage.has(n.id));
            node.classed("clicked", n => n.id === d.id);
            link.classed("dimmed", l => !lineage.has(l.source) || !lineage.has(l.target));
            focusedNode = d;
            zoomToLineage(lineage);
        }
        // Remove highlight arrow when node is clicked
        d3.select(this).select('.highlight-arrow').remove();
    }
    function highlightHoverLineage(event, d) {
        const lineage = new Set();
        const getAncestors = (node) => {
            lineage.add(node.id);
            if (node.variant) {
                const parentNode = nodes.find(n => n.name === node.variant);
                if (parentNode) {
                    lineage.add(parentNode.id);
                    getAncestors(parentNode);
                }
            } else {
                node.parents.forEach(parentId => {
                    const parent = nodes.find(n => n.id === parentId);
                    if (parent) {
                        lineage.add(parentId);
                        getAncestors(parent);
                    }
                });
            }
        };
        const getDescendants = (nodeId) => {
            lineage.add(nodeId);
            const children = nodes.filter(n => n.parents.includes(nodeId) || (n.variant === nodes.find(node => node.id === nodeId).name));
            children.forEach(child => {
                lineage.add(child.id);
                getDescendants(child.id);
            });
        };
        getAncestors(d);
        getDescendants(d.id);
        node.classed("highlighted", n => lineage.has(n.id));
        link.classed("highlighted", l => lineage.has(l.source) && lineage.has(l.target));
    }
    function removeHighlightHoverLineage() {
        node.classed("highlighted", false);
        link.classed("highlighted", false);
    }
    function zoomToLineage(lineage) {
        const activeNodes = nodes.filter(n => lineage.has(n.id));
        const minX = d3.min(activeNodes, n => n.x) - standardPillWidth / 2;
        const maxX = d3.max(activeNodes, n => n.x) + standardPillWidth / 2;
        const minY = d3.min(activeNodes, n => n.y) - pillHeight / 2;
        const maxY = d3.max(activeNodes, n => n.y) + pillHeight / 2;
        const padding = 50;
        const currentTransform = d3.zoomTransform(svg.node());
        const currentScale = currentTransform.k;
        const currentViewport = {
            minX: -currentTransform.x / currentScale,
            minY: -currentTransform.y / currentScale,
            maxX: (-currentTransform.x + width) / currentScale,
            maxY: (-currentTransform.y + height) / currentScale
        };
        const isFullyVisible = minX >= currentViewport.minX &&
                               maxX <= currentViewport.maxX &&
                               minY >= currentViewport.minY &&
                               maxY <= currentViewport.maxY;
        if (!isFullyVisible) {
            const scale = Math.min(
                width / (maxX - minX + 2 * padding),
                height / (maxY - minY + 2 * padding)
            );
            const translate = [
                (width - scale * (maxX + minX)) / 2,
                (height - scale * (maxY + minY)) / 2
            ];
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(translate[0], translate[1])
                    .scale(scale));
        }
    }
    function resetZoom() {
        svg.transition()
            .duration(750)
            .call(zoom.transform, initialTransform);
    }
    const initialTransform = d3.zoomIdentity
        .translate(0, 0)
        .scale(0.4);
    svg.call(zoom.transform, initialTransform);
};
const getColorByDominance = (dominance) => {
    switch(dominance.toLowerCase()) {
        case 'sativa dominant': return '#ebdc70ff';
        case 'indica dominant': return '#adcbc9ff';
        case 'balanced hybrid': return '#ccd094ff';
        case 'unknown': return '#f3f6e8';
        default: return '#EAEAEA';
    }
};
const darkenColor = (color, amount) => d3.color(color).darker(amount / 10).toString();
const lightenColor = (color, amount) => d3.color(color).brighter(amount / 100).toString();

function setupStrainSearch() {
    const searchInput = document.getElementById('strainSearch');
    const dropdown = document.getElementById('strainDropdown');
    let highlightedNode = null;

    searchInput.addEventListener('input', function() {
        const searchText = this.value.toLowerCase();
        if (searchText.length === 0) {
            dropdown.style.display = 'none';
            return;
        }

        const matchingStrains = nodes.filter(node => 
            !node.name.toLowerCase().includes('unknown') && (
                node.name.toLowerCase().includes(searchText) ||
                (node.product && node.product.toLowerCase().includes(searchText)) ||
                (node.alsoKnownAs && node.alsoKnownAs.toLowerCase().includes(searchText))
            )
        );

        dropdown.innerHTML = '';
        matchingStrains.sort((a, b) => a.name.localeCompare(b.name)).forEach(strain => {
            const div = document.createElement('div');
            div.innerHTML = strain.name + 
                            (strain.product ? `<br>(${strain.product})` : '') + 
                            (strain.alsoKnownAs ? ` [${strain.alsoKnownAs}]` : '');
            div.addEventListener('click', () => {
                highlightStrain(strain);
                dropdown.style.display = 'none';
                searchInput.value = '';
            });
            dropdown.appendChild(div);
        });

        dropdown.style.display = matchingStrains.length > 0 ? 'block' : 'none';
    });

    document.addEventListener('click', function(event) {
        if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
            dropdown.style.display = 'none';
        }
    });

    function highlightStrain(strain) {
        if (highlightedNode) {
            d3.select(highlightedNode).select('.highlight-arrow').remove();
            highlightedNode = null;
        }

        const node = g.selectAll('.node').filter(d => d.id === strain.id);
        const arrow = node.append('path')
            .attr('d', 'M-200,-20 L-120,0 L-200,20 Z')
            .attr('class', 'highlight-arrow')
            .attr('fill', 'red')
            .attr('transform', 'translate(0,0)');

        arrow.on('mouseover', function() {
            d3.select(this).remove();
            highlightedNode = null;
        });

        node.on('click', function() {
            d3.select(this).select('.highlight-arrow').remove();
            highlightedNode = null;
        });

        highlightedNode = node.node();

        zoomToNode(strain);
    }

    function zoomToNode(strain) {
        const transform = d3.zoomTransform(svg.node());
        const scale = 2;
        const x = -strain.x * scale + svg.attr('width') / 2;
        const y = -strain.y * scale + svg.attr('height') / 2;

        svg.transition()
            .duration(750)
            .call(d3.zoom().transform, d3.zoomIdentity.translate(x, y).scale(scale));
    }
}

window.onload = fetchData;
window.addEventListener('resize', () => {
    createLineageChart();
    adjustRibbonFontSize();
});

function adjustRibbonFontSize() {
    const ribbon = document.querySelector('.header-ribbon');
    const title = document.querySelector('.header-ribbon h1');
    const buttons = document.querySelectorAll('.header-buttons .btn');
    const searchInput = document.getElementById('strainSearch');

    let fontSize = 18; // Starting font size
    let titleFits = false;
    let buttonsFit = false;

    while (fontSize >= 4 && (!titleFits || !buttonsFit)) {
        // Adjust title font size
        title.style.fontSize = `${fontSize}px`;
        titleFits = title.scrollWidth <= ribbon.clientWidth * 0.5; // Allow title to take up to 50% of ribbon width

        // Adjust buttons font size
        buttons.forEach(btn => btn.style.fontSize = `${fontSize * 0.5}px`); // Buttons are 50% of title size
        searchInput.style.fontSize = `${fontSize * 0.5}px`; // Search input same as buttons
        buttonsFit = Array.from(buttons).every(btn => btn.scrollWidth <= btn.clientWidth) &&
                     searchInput.scrollWidth <= searchInput.clientWidth;

        if (!titleFits || !buttonsFit) {
            fontSize--;
        }
    }

    // Ensure minimum font size
    if (fontSize < 4) {
        fontSize = 4;
        title.style.fontSize = `${fontSize}px`;
        buttons.forEach(btn => btn.style.fontSize = `${fontSize * 0.5}px`);
        searchInput.style.fontSize = `${fontSize * 0.5}px`;
    }
}

const togglePopup = (popupId) => {
    const popup = document.getElementById(popupId);
    const overlay = document.querySelector('.popup-overlay');
    const allPopups = document.querySelectorAll('.popup');
    allPopups.forEach(p => { if (p.id !== popupId) p.style.display = 'none'; });
    if (popup.style.display === 'block') {
        popup.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        popup.style.display = 'block';
        overlay.style.display = 'block';
    }
};
['btn1', 'btn2', 'btn3'].forEach(id => 
    document.getElementById(id).addEventListener('click', () => togglePopup(`popup${id.replace('btn', '')}`))
);
document.querySelector('.popup-overlay').addEventListener('click', function() {
    document.querySelectorAll('.popup').forEach(popup => popup.style.display = 'none');
    this.style.display = 'none';
});
document.querySelectorAll('.popup').forEach(popup => 
    popup.addEventListener('click', event => event.stopPropagation())
);
</script>
</body>
</html>
